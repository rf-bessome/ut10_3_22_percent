////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Универсальные механизмы библиотек интеграции с государственными информационными системами:
//  * ЕГАИС,
//  * ГИСМ,
//  * ВетИС,
//  * ИСМП
// Состав модуля:
//
//  * Функции работы с прикладными документами (вывод привязки библиотечных документов, оповещений итп).
//  * Общие функции проведения документов.
//  * Общие функции для работы с протоколом обмена (Присоединенные файлы)
//  * Функции общего назначения.
//

#Область ПрограммныйИнтерфейс

// Версия библиотеки
// 
// Возвращаемое значение:
//  Строка - Версия библиотеки
Функция ВерсияБиблиотеки() Экспорт
	
	Возврат "1.1.30.108";
	
КонецФункции

// Версия подсистемы
// 
// Параметры:
//  Редакция - Строка - Редакция
// 
// Возвращаемое значение:
//  Строка - Версия подсистемы
Функция ВерсияПодсистемы(Редакция = "1") Экспорт
	
	Разделитель = ".";
	ВерсияБиблиотеки = ВерсияБиблиотеки();
	ЧастиВерсииБиблиотеки = СтрРазделить(ВерсияБиблиотеки, Разделитель);
	
	ЧастиВерсииБиблиотеки[0] = Редакция;
	
	Возврат СтрСоединить(ЧастиВерсииБиблиотеки, Разделитель);
	
КонецФункции

// Вычисляет пересечение массивов. Пересечением массивов А и В является массив, содержащий
// все элементы массива А, существующие также и в массиве В.
//
// Параметры:
//  Массив1 - Массив - массив элементов;
//  Массив2 - Массив - массив элементов.
// 
// Возвращаемое значение:
//  Массив - пересечение массивов В и А.
//
// Пример:
//	//А = [1, 3, 5, 7];
//	//В = [3, 7, 9];
//	Результат = ПересечениеМассивов(А, В);
//	//Результат = [3, 7];
//
Функция ПересечениеМассивов(Массив1, Массив2) Экспорт
	
	Результат = Новый Массив;
	
	Ключи = Новый Соответствие;
	Для Каждого Элемент Из Массив1 Цикл
		Ключи.Вставить(Элемент, Истина);
	КонецЦикла;
	Для Каждого Элемент Из Массив2 Цикл
		Если Ключи.Получить(Элемент)<>Неопределено Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - Массив Из Структура - Массив структур, которые будут преобразованы в таблиц значений.
//										   Свойства структуры первого элемента массива определяют состав колонок результирующей таблицы.
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур.
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

// Текст исключения обработки статуса
//
// Параметры:
//  Документ - ДокументСсылка - Документ.
//  Операция - ПеречислениеСсылка - Операция.
// 
// Возвращаемое значение:
//  Строка - Текст исключения.
//
Функция ТекстИсключенияОбработкиСтатуса(Документ, Операция) Экспорт
	
	Возврат СтрШаблон(
		НСтр("ru = 'При изменении статуса документа %1 не обработана операция %2'"),
		Документ,
		Операция);
	
КонецФункции

// Возвращает массив/список значений пустых значений составного типа, включая Неопределено
// 
// Параметры:
// 	ВходящееОписаниеТипа - ОписаниеТипов - Описание типов метаданного для получения типов.
// 	ВозвращатьСписокЗначений - Булево - Выбор возвращаемого значения Масси или СписокЗначений.
// Возвращаемое значение:
// 	Массив, СписокЗначений - коллекция пустых значений составного типа.
//
Функция МассивПустыхЗначенийСоставногоТипа(ВходящееОписаниеТипа, ВозвращатьСписокЗначений=Ложь) Экспорт
	
	МассивТипов = Новый Массив;
	
	Для Каждого ЭлементТип Из ВходящееОписаниеТипа.Типы() Цикл
		МассивТиповПоЭлементу = Новый Массив;
		МассивТиповПоЭлементу.Добавить(ЭлементТип);
		ОписаниеТипаПоЭлементу = Новый ОписаниеТипов(МассивТиповПоЭлементу);
		МассивТипов.Добавить(ОписаниеТипаПоЭлементу.ПривестиЗначение(Неопределено));
	КонецЦикла;
	
	Если МассивТипов.Найти(Неопределено) = Неопределено Тогда
		МассивТипов.Добавить(Неопределено);
	КонецЕсли;
	
	Если ВозвращатьСписокЗначений Тогда
		СписокЗначенийИтог = Новый СписокЗначений;
		СписокЗначенийИтог.ЗагрузитьЗначения(МассивТипов);
		Возврат СписокЗначенийИтог;
	Иначе
		Возврат МассивТипов;
	КонецЕсли;
	
КонецФункции

// Рассчитать хеш для строки
// 
// Параметры:
//  СтрокаДляРасчетаХеша - Строка - Строка для расчета хеша
// Возвращаемое значение:
//  Строка - Описание
Функция ХешированиеДанныхSHA256(СтрокаДляРасчетаХеша, ФорматBase64 = Истина) Экспорт
	
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(СтрокаДляРасчетаХеша);
	
	Если ФорматBase64 Тогда
		Возврат Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	Иначе
		Возврат ХешированиеДанныхОбъект.ХешСумма;
	КонецЕсли;
	
КонецФункции

#Область ОбменСИспользованиемЭДО

// Получает структуру настроек обмена через ЭДО, извлекая из константы НастройкиОбменаГосИС.
// 
// Возвращаемое значение:
//  ТаблицаЗначений, Неопределено - Настройки обмена.
//
Функция НастройкиОбменаГосИС() Экспорт
	
	ХранилищеЗначения = Константы.НастройкиОбменаГосИС.Получить();
	
	Если ХранилищеЗначения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкиОбмена = ХранилищеЗначения.Получить();
	
	Возврат НастройкиОбмена;
	
КонецФункции

Функция СертификатыОрганизаций() Экспорт
	
	СертификатыОрганизаций = Новый ТаблицаЗначений();
	СертификатыОрганизаций.Колонки.Добавить("Организация", ОпределяемыеТипы().Организация.Тип);
	
	НастройкиОбменаГосИС = НастройкиОбменаГосИС();
	
	Если НастройкиОбменаГосИС = Неопределено Тогда
		Возврат СертификатыОрганизаций;
	КонецЕсли;
	
	Для Каждого Строка Из НастройкиОбменаГосИС Цикл
		ЗаполнитьЗначенияСвойств(СертификатыОрганизаций.Добавить(), Строка);
	КонецЦикла;
	
	Возврат СертификатыОрганизаций;
	
КонецФункции

#КонецОбласти

#Область ФорматированиеXML

// Инициализирует объект ПараметрыЗаписиXML.
//
// Параметры:
//  ИспользоватьОтступы - Булево - признак использования отступов, по умолчанию Истина.
//  СимволОтступа       - Строка - символ, которым отображается отступ, по умолчанию два пробела.
//  Кодировка           - Строка - Кодировка текста.
// 
// Возвращаемое значение:
//  ПараметрыЗаписиXML - набор параметров, который используется при записи XML.
//
Функция ПараметрыФорматированияXML(ИспользоватьОтступы = Истина, СимволОтступа = "  ", Кодировка = "UTF-8") Экспорт
	
	ПараметрыЗаписи = Новый ПараметрыЗаписиXML(
		Кодировка,
		"1.0",
		ИспользоватьОтступы,
		ИспользоватьОтступы,
		СимволОтступа);
	
	Возврат ПараметрыЗаписи;
	
КонецФункции

// Форматирует текст сообщения в формате XML
//
// Параметры:
//  ТекстСообщенияXML       - Строка - текст сообщения, который.
//  ПараметрыФорматирования - ПараметрыЗаписиXML - параметры записи XML.
// 
// Возвращаемое значение:
//  Строка - отформатированная строка XML.
//
Функция ФорматироватьXMLСПараметрами(ТекстСообщенияXML, ПараметрыФорматирования) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстСообщенияXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку(ПараметрыФорматирования);
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Форматирует текст сообщения в формате XML
//
// Параметры:
//  ТекстСообщенияXML   - Строка - текст сообщения, который.
//  ИспользоватьОтступы - Булево - признак использования отступов, по умолчанию Истина.
//  СимволОтступа       - Строка - символ, которым отображается отступ, по умолчанию два пробела.
// 
// Возвращаемое значение:
//  Строка - отформатированная строка XML.
//
Функция ФорматироватьXML(ТекстСообщенияXML, ИспользоватьОтступы = Истина, СимволОтступа = " ") Экспорт
	
	ПараметрыФорматирования = ПараметрыФорматированияXML(ИспользоватьОтступы, СимволОтступа);
	
	Возврат ФорматироватьXMLСПараметрами(ТекстСообщенияXML, ПараметрыФорматирования);
	
КонецФункции

#КонецОбласти

#Область ФорматированиеJSON

// Форматирует текст сообщения в формате JSON
//
// Параметры:
//  ТекстСообщенияJSON           - Строка - текст сообщения, который.
//  УдалитьПробелыИПереносыСтрок - Булево - признак использования отступов, по умолчанию Ложь.
//  КлючиРазворачиванияBASE64 - Неопределено -
//                            - Соответствие Из КлючИЗначение:
//  * Ключ - Строка - Имя свойства для разворота BASE64
//  * Значение - Неопределено - не используется
// Возвращаемое значение:
//  Строка - отформатированная строка JSON.
//
Функция ФорматироватьJSON(ТекстСообщенияJSON, УдалитьПробелыИПереносыСтрок = Ложь, КлючиРазворачиванияBASE64 = Неопределено) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(ТекстСообщенияJSON);
	
	Данные = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	
	Если КлючиРазворачиванияBASE64 <> Неопределено
		И ТипЗнч(Данные) <> Тип("Массив") Тогда
		Для Каждого КлючИЗначение Из КлючиРазворачиванияBASE64 Цикл
			ДанныеПоКлючу = Данные[КлючИЗначение.Ключ];
			Если ДанныеПоКлючу = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Данные[КлючИЗначение.Ключ] = ТекстJSONВОбъект(ШтрихкодированиеИСКлиентСервер.Base64ВШтрихкод(ДанныеПоКлючу), Истина);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ОбъектВТекстJSON(Данные, УдалитьПробелыИПереносыСтрок);
	
КонецФункции

// Получить из текста JSON структуру.
// 
// Параметры:
// 	ТекстJSON                    - Строка - Текст JSON.
// 	ПреобразовыватьВСоответствие - Булево - Признак преобразования в соответствие.
// Возвращаемое значение:
// 	Структура, Неопределено - Результат преобразования JSON.
Функция ТекстJSONВОбъект(ТекстJSON, ПреобразовыватьВСоответствие = Ложь) Экспорт
	
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(ТекстJSON);
	
	Попытка
		РезультатРазбора = ПрочитатьJSON(Чтение, ПреобразовыватьВСоответствие);
	Исключение
		РезультатРазбора = Неопределено;
	КонецПопытки;
	
	Возврат РезультатРазбора;
	
КонецФункции

// Формирует из структуры текст JSON
// 
// Параметры:
// 	Структура                    - Структура - Произвольная структура данных
//  УдалитьПробелыИПереносыСтрок - Булево    - признак использования отступов, по умолчанию Истина.
// Возвращаемое значение:
// 	Строка - Текст JSON
Функция ОбъектВТекстJSON(Структура, УдалитьПробелыИПереносыСтрок = Ложь) Экспорт
	
	Если УдалитьПробелыИПереносыСтрок Тогда
		ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "");
	Иначе
		ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, "  ");
	КонецЕсли;
	
	ЗаписьJSON = Новый ЗаписьJSON();
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	ЗаписатьJSON(ЗаписьJSON, Структура);
	
	ТекстJSON = ЗаписьJSON.Закрыть();
	
	Возврат ТекстJSON;
	
КонецФункции

#КонецОбласти

#Область РаботаСXDTO

// Возвращает все пространства зависимые пространства имен из коллекции пакетов.
//
Процедура ЗависимыеПространстваИмен(ЗависимыеПакеты, ПространстваИмен) Экспорт
	
	Для Каждого ПакетXDTO Из ЗависимыеПакеты Цикл
		Если ПространстваИмен.Найти(ПакетXDTO.URIПространстваИмен) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ПространстваИмен.Добавить(ПакетXDTO.URIПространстваИмен);
		
		ЗависимыеПространстваИмен(ПакетXDTO.Зависимости, ПространстваИмен);
	КонецЦикла;
	
КонецПроцедуры

// Создает ОбъектXDTO из пространства имен по имени свойства.
//
// Возвращаемое значение:
//   ОбъектXDTO
Функция ОбъектXDTOПоИмениТипа(ОбъектXDTOРодитель, ИмяТипа) Экспорт
	
	Если ТипЗнч(ОбъектXDTOРодитель) = Тип("СписокXDTO") Тогда
		ТипОбъекта = ОбъектXDTOРодитель.ВладеющееСвойство.Тип.Свойства.Получить(ИмяТипа).Тип;
	Иначе
		ТипОбъекта = ОбъектXDTOРодитель.Тип().Свойства.Получить(ИмяТипа).Тип;
	КонецЕсли; 
	
	Возврат ФабрикаXDTO.Создать(ТипОбъекта);
	
КонецФункции

// Создает ОбъектXDTO из пространства имен по имени свойства.
//
// Возвращаемое значение:
//   ОбъектXDTO
Функция ОбъектXDTOПоИмениСвойства(ПространствоИмен, ИмяСвойства, ОбъектXDTOРодитель = Неопределено) Экспорт
	
	Если ОбъектXDTOРодитель = Неопределено Тогда
		ТипОбъекта = ФабрикаXDTO.Пакеты.Получить(ПространствоИмен).КорневыеСвойства.Получить(ИмяСвойства).Тип;
	Иначе
		СвойствоРодителя = ОбъектXDTOРодитель.Тип().Свойства.Получить(ИмяСвойства);
		Если СвойствоРодителя = Неопределено Тогда
			ТипОбъекта = ФабрикаXDTO.Пакеты.Получить(ПространствоИмен).КорневыеСвойства.Получить(ИмяСвойства).Тип;
		Иначе
			ТипОбъекта = СвойствоРодителя.Тип;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ФабрикаXDTO.Создать(ТипОбъекта);
	
КонецФункции

// Преобразует объект XDTO в структуру
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект XDTO
//  ПараметрыПреобразования - Неопределено, Структура - дополнительные переметры преобразования объекта
// 
// Возвращаемое значение:
//  Структура - Структура объекта.
//
Функция ОбъектXDTOВСтруктуру(ОбъектXDTO, ПараметрыПреобразования = Неопределено) Экспорт
	
	Структура      = Новый Структура;
	ТипОбъектаXDTO = ОбъектXDTO.Тип();
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		ИмяСвойства      = Свойство.Имя;
		ЗначениеСвойства = ОбъектXDTO[ИмяСвойства];
		
		Если ТипЗнч(ЗначениеСвойства) = Тип("ОбъектXDTO") Тогда
			
			Структура.Вставить(ИмяСвойства, ОбъектXDTOВСтруктуру(ЗначениеСвойства, ПараметрыПреобразования));
			
		ИначеЕсли ТипЗнч(ЗначениеСвойства) = Тип("СписокXDTO") Тогда
			
			Структура.Вставить(ИмяСвойства, Новый Массив);
			Для Индекс = 0 По ЗначениеСвойства.Количество() - 1 Цикл
				
				ЭлементСписка = ЗначениеСвойства.Получить(Индекс);
				Если ТипЗнч(ЭлементСписка) = Тип("ОбъектXDTO") Тогда
					Структура[ИмяСвойства].Добавить(ОбъектXDTOВСтруктуру(ЭлементСписка, ПараметрыПреобразования));
				Иначе
					Структура[ИмяСвойства].Добавить(ЭлементСписка);
				КонецЕсли;
				
			КонецЦикла;
			
		Иначе
			
			Структура.Вставить(ИмяСвойства, ЗначениеСвойства);
			
			Если ПараметрыПреобразования <> Неопределено
				И ПараметрыПреобразования.НайтиИдентификаторы
				И Свойство.Тип = ПараметрыПреобразования.ТипUUID Тогда
				
				РезультатПоиска = ПараметрыПреобразования.ТипыИдентификаторов[ТипОбъектаXDTO];
				Если РезультатПоиска <> Неопределено
					И РезультатПоиска.ИмяПоля = ИмяСвойства Тогда
					ПараметрыПреобразования.Идентификаторы[РезультатПоиска.ИмяТаблицы].Вставить(ЗначениеСвойства, РезультатПоиска.ПустоеЗначение);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает новый объект XDTO.
//
// Параметры:
//  ПространствоИмен - Строка - Пространство имен.
//  ИмяТипа - Строка - Имя типа в пространстве имен.
// 
// Возвращаемое значение:
//  ОбъектXDTO - Созданный объект XDTO/
//
Функция ОбъектXDTO(ПространствоИмен, ИмяТипа) Экспорт
	
	Возврат ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, ИмяТипа));
	
КонецФункции

// Устанавливает значение свойства объекта XDTO,
// с проверкой на наличие свойства и необходимость заполнения.
//
// Параметры:
//  ОбъектXDTO       - ОбъектXDTO   - объект в котором заполняется свойство
//  ИмяСвойства      - Строка       - имя свойства
//  ЗначениеСвойства - Произвольный - значение свойства
//  КешОшибок        - Структура    - см. ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки()
//  Расшифровки      - Структура    - см. ДанныеДляРасшифровкиОшибок()
//  ТребуетсяЗаполнить - Булево     - Признак необходимости заполнения свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если значение было заполнено
//
Функция ЗаполнитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки, ТребуетсяЗаполнить = Неопределено) Экспорт
	
	Если Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектXDTO, ИмяСвойства) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТребуетсяЗаполнить = Неопределено Тогда
		РазрешеноНеЗаполнять = ОбъектXDTO.Тип().Свойства.Получить(ИмяСвойства).НижняяГраница = 0;
	Иначе
		РазрешеноНеЗаполнять = Не ТребуетсяЗаполнить;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеСвойства) <> Тип("ОбъектXDTO") И ТипЗнч(ЗначениеСвойства) <> Тип("СписокXDTO") Тогда
		Если Не ЗначениеЗаполнено(ЗначениеСвойства)
			И РазрешеноНеЗаполнять Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	УстановитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки);
	
	Возврат Истина;
	
КонецФункции

// Устанавливает значение свойства объекта XDTO (для списка - добавляет элемент в список), без проверок
//
// Параметры:
//  ОбъектXDTO       - ОбъектXDTO   - объект в котором заполняется свойство
//  ИмяСвойства      - Строка       - имя свойства
//  ЗначениеСвойства - Произвольный - значение свойства
//  КешОшибок        - Структура    - см ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки()
//  Расшифровки      - Структура    - см ДанныеДляРасшифровкиОшибок()
//
Процедура УстановитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки) Экспорт
	
	Попытка
		Если ТипЗнч(ОбъектXDTO[ИмяСвойства]) = Тип("СписокXDTO") Тогда
			ОбъектXDTO[ИмяСвойства].Добавить(ЗначениеСвойства);
		Иначе
			ОбъектXDTO[ИмяСвойства] = ЗначениеСвойства;
		КонецЕсли;
	Исключение
		ЧтениеXML = Новый Структура;
		ЧтениеXML.Вставить("Имя"                , ИмяСвойства);
		ЧтениеXML.Вставить("ЛокальноеИмя"       , ИмяСвойства);
		ЧтениеXML.Вставить("Значение"           , ЗначениеСвойства);
		ЧтениеXML.Вставить("ТипУзла"            , ТипУзлаXML.КонецЭлемента);
		ЧтениеXML.Вставить("URIПространстваИмен", ОбъектXDTO.Тип().URIПространстваИмен);
		
		ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = ПредставлениеОшибкиXDTO(ТекстОшибки, ЧтениеXML, Расшифровки);
		
		Если КешОшибок <> Неопределено Тогда
			ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки(КешОшибок, ТекстОшибки);
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

// Возвращает пользовательское представление ошибки
//
// Параметры:
//  ПредставлениеОшибки	 - Строка               - представление ошибки до обработки
//  ЧтениеXML            - ЧтениеXML, Структура - ошибочный узел данных
//  Расшифровки          - Структура            - см. ДанныеДляРасшифровкиОшибок()
// 
// Возвращаемое значение:
//  Строка - представление ошибки после обработки
//
Функция ПредставлениеОшибкиXDTO(ПредставлениеОшибки, ЧтениеXML, Расшифровки) Экспорт
	
	Если СтрНайти(ПредставлениеОшибки, НСтр("ru = 'Ошибка проверки данных XDTO'")) = 0
		И СтрНайти(ПредставлениеОшибки, НСтр("ru = 'Несоответствие типов XDTO'")) = 0 Тогда
		Возврат ПредставлениеОшибки;
	КонецЕсли;
	
	ЗначениеПоля = ЧтениеXML.Значение;
	Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
		ЧтениеXML.Прочитать();
	КонецЕсли;
	
	Если Расшифровки.Таблица = Неопределено Тогда
		Расшифровки.Таблица = ПредставленияПолей(Расшифровки.ИмяМакета);
	КонецЕсли;
	
	Отбор = Новый Структура;
	Отбор.Вставить("ПространствоИмен", ЧтениеXML.URIПространстваИмен);
	Отбор.Вставить("ЛокальноеИмя",     ЧтениеXML.ЛокальноеИмя);
	
	МассивСтрок = Расшифровки.Таблица.НайтиСтроки(Отбор);
	
	СтрокаТаблицы = Неопределено;
	Если МассивСтрок.Количество() = 1 Тогда
		СтрокаТаблицы = МассивСтрок[0];
	ИначеЕсли МассивСтрок.Количество() > 1 И НЕ Расшифровки.Глубина = Неопределено Тогда
		Отбор.Вставить("Глубина", Расшифровки.Глубина);
		МассивСтрокПоГлубине = Расшифровки.Таблица.НайтиСтроки(Отбор);
		Если МассивСтрокПоГлубине.Количество() > 0 Тогда
			СтрокаТаблицы = МассивСтрокПоГлубине[0];
		Иначе
			СтрокаТаблицы = МассивСтрок[0];
		КонецЕсли;
	КонецЕсли;
	
	Если СтрокаТаблицы <> Неопределено Тогда
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если НЕ ЗначениеЗаполнено(ЗначениеПоля) Тогда
				ПредставлениеОшибки = НСтр("ru = 'Не заполнено значение поля ""%1"" (%2)'");
				ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, СтрокаТаблицы.Представление, ЧтениеXML.Имя);
			Иначе
				ПредставлениеОшибки = НСтр("ru = 'Некорректное значение ""%1"" поля ""%2"" (%3)'");
				ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, ЗначениеПоля, СтрокаТаблицы.Представление, ЧтениеXML.Имя);
			КонецЕсли;
		Иначе
			ИндексСтроки = Расшифровки.Таблица.Индекс(СтрокаТаблицы);
			
			Пока ИндексСтроки > 0 Цикл
				ПредыдущееПоле = Расшифровки.Таблица[ИндексСтроки - 1];
				Если ПредыдущееПоле.ПространствоИмен <> СтрокаТаблицы.ПространствоИмен Тогда
					Прервать;
				КонецЕсли;
				Если ПредыдущееПоле.Обязательное Тогда
					ПредставлениеОшибки = НСтр("ru = 'Отсутствует обязательное поле ""%1"" (%2)'");
					ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, ПредыдущееПоле.Представление, ПредыдущееПоле.ЛокальноеИмя);
					Прервать;
				КонецЕсли;
				ИндексСтроки = ИндексСтроки - 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПредставлениеОшибки;
	
КонецФункции

// Возвращает Объект XDTO, получаемый из текста сообщения XML
//
// Параметры:
//  ТекстСообщенияXML - Строка - Текст сообщения XML
// 
// Возвращаемое значение:
//  ОбъектXDTO - Объект XDTO
//
Функция ПроизвольныйОбъектXDTOПоТекстуСообщенияXML(ТекстСообщенияXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстСообщенияXML);
	
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
	Возврат ОбъектXDTO;
	
КонецФункции

// Возвращается значение свойства объекта XDTO при его наличии.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект для получения свойства.
//  ПутьКСвойству - Строка - Путь к свойству объекта, возможно разделенный точками (.).
// 
// Возвращаемое значение:
//  Неопределено, ОбъектXDTO, СписокXDTO, СвойствоXDTO, Строка, Число - Значение свойства объекта XDTO.
Функция ЗначениеСвойстваОбъектаXDTO(ОбъектXDTO, ПутьКСвойству) Экспорт
	
	ПутиКСвойству = СтрРазделить(ПутьКСвойству, ".");
	ТекущийОбъект = ОбъектXDTO;
	Для Каждого ТекущийПуть Из ПутиКСвойству Цикл
		СвойствоОбъекта = ТекущийОбъект.Свойства().Получить(ТекущийПуть);
		Если ТипЗнч(СвойствоОбъекта) = Тип("СвойствоXDTO") Тогда
			Если (СвойствоОбъекта.ВерхняяГраница = -1) Или (СвойствоОбъекта.ВерхняяГраница > 1) Тогда
				ТекущийОбъект = ТекущийОбъект.ПолучитьСписок(ТекущийПуть);
			Иначе
				ТекущийОбъект = ТекущийОбъект.Получить(ТекущийПуть);
			КонецЕсли;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекущийОбъект;
	
КонецФункции

#КонецОбласти

#Область РаботаСЗапросами

Функция РазделительЗапросовВПакете() Экспорт
	
	Разделитель = ";
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	Возврат Разделитель;
	
КонецФункции
	
// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//  Запрос				 - Запрос	 - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса		 - СписокЗначений	 - в списке перечислены тексты запросов и их имена.
//  ВыгрузитьРезультат	 - Булево			 - Истина, если результат запроса нужно выгрузить в таблицы значений.
// 
// Возвращаемое значение:
//  Структура - структура в которую помещены полученные таблицы
//
Функция ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ВыгрузитьРезультат = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	МассивТекстаЗапроса = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстаЗапроса.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли;
		МассивТекстаЗапроса.Добавить(ТекстЗапроса.Значение);
		МассивТекстаЗапроса.Добавить(РазделительЗапросовВПакете());
		
	КонецЦикла;
	
	Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Символы.ПС);
	
	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	КоличествоЗапросовВПакете = 0;
	
	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		
		Если СтрЧислоВхождений(ТекстЗапроса.Значение, ";") > 0 Тогда
			Подзапросы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТекстЗапроса.Значение, ";");
			КоличествоПодзапросов = Подзапросы.Количество();
			ИндексЗапросаРезультате = Неопределено;
			Для Индекс = -(КоличествоПодзапросов - 1) По 0 Цикл
				Если Найти(Подзапросы[-Индекс], "#РезультатЗапроса#") > 0 Тогда
					ИндексЗапросаРезультате = -Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ИндексЗапросаРезультате = Неопределено Тогда
				ИндексЗапросаРезультате = КоличествоПодзапросов - 1;
			КонецЕсли;
		Иначе
			КоличествоПодзапросов = 1;
			ИндексЗапросаРезультате = 0;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			РезультатТаблица = Результат[КоличествоЗапросовВПакете + ИндексЗапросаРезультате];
			РезультатТаблица = ?(ВыгрузитьРезультат, РезультатТаблица.Выгрузить(), РезультатТаблица);
			Таблицы.Вставить(ТекстЗапроса.Представление, РезультатТаблица);
		КонецЕсли;
		
		КоличествоЗапросовВПакете = КоличествоЗапросовВПакете + КоличествоПодзапросов;
		
	КонецЦикла;
	
	Возврат Таблицы;
	
КонецФункции

#КонецОбласти

#Область ФормыДокументовОснований

// Параметры вывода гиперссылок на документы ИС в форме документа-основания.
//
// Параметры:
//  ИменаПодсистем           - Строка - имена подсистем (через запятую), на объекты которых нужны гиперссылки
//  ИмяЭлементаДляРазмещения - Строка - имя реквизита формы, для размещения гиперссылок
// 
// Возвращаемое значение:
//  Структура - согласно параметрам
//
Функция ПараметрыИнтеграцииВФорме(ИменаПодсистем = "", ИмяЭлементаДляРазмещения = "") Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИменаПодсистем",           ИменаПодсистем);
	Результат.Вставить("ИмяЭлементаДляРазмещения", ИмяЭлементаДляРазмещения);
	Возврат Результат;
	
КонецФункции

Функция ИмяЭлементаДляРазмещения() Экспорт
	
	Возврат "ГруппаИнтеграция";
	
КонецФункции

// Процедура - При создании на сервере в форме документа основания
//
// Параметры:
//  Форма               - ФормаКлиентскогоПриложения     - форма прикладного объекта для встраивания библиотечной гиперссылки
//  Объект              - ДанныеФормыСтруктура - данные прикладного объекта
//  ПараметрыИнтеграции - См. ПараметрыИнтеграцииВФорме
//
Процедура ПриСозданииНаСервереВФормеДокументаОснования(Форма, Объект, Знач ПараметрыИнтеграции) Экспорт
	
	ИнтегрируемыеПодсистемы = Новый Структура;
	Реквизиты = Новый Массив;
	
	Для Каждого КлючИЗначение Из Новый Структура(ПараметрыИнтеграции.ИменаПодсистем) Цикл
		
		// Проверим использование подсистемы.
		ИмяПодсистемы = КлючИЗначение.Ключ;
		
		ИспользованиеПодсистемы = Ложь;
		Если ПодсистемаСуществует(ИмяПодсистемы) Тогда
			
			МодульИнтеграции = ОбщийМодуль(ИмяПодсистемы);
			ИспользованиеПодсистемы = МодульИнтеграции.ИспользуетсяИнтеграцияВФормеДокументаОснования(Форма, Объект);
			
		КонецЕсли;
		
		Если НЕ ИспользованиеПодсистемы Тогда
			Продолжить;
		КонецЕсли;
		
		ИнтегрируемыеПодсистемы.Вставить(ИмяПодсистемы);
		
		// Добавим реквизит формы для подсистемы.
		Реквизиты.Добавить(Новый РеквизитФормы(
			ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы),
			Новый ОписаниеТипов("ФорматированнаяСтрока")));
		
	КонецЦикла;
	
	Если ИнтегрируемыеПодсистемы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Добавим служебный реквизит описания всех используемых подсистем.
	Реквизиты.Добавить(Новый РеквизитФормы(
		ИнтеграцияИСКлиентСервер.ИмяПоляОписанияИнтеграцийВФормеДокументаОснования(),
		Новый ОписаниеТипов()));
	
	// Создадим реквизиты формы.
	Форма.ИзменитьРеквизиты(Реквизиты);
	
	Форма[ИнтеграцияИСКлиентСервер.ИмяПоляОписанияИнтеграцийВФормеДокументаОснования()] =
		Новый ФиксированнаяСтруктура(ИнтегрируемыеПодсистемы);
		
	ЭлементРодитель = Форма.Элементы.Найти(ПараметрыИнтеграции.ИмяЭлементаДляРазмещения);
	Если ЭлементРодитель <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ИнтегрируемыеПодсистемы Цикл
			
			ИмяПодсистемы = КлючИЗначение.Ключ;
			
			// Создадим элемент формы для подсистемы.
			ПолеНадписи = Форма.Элементы.Добавить(
				ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы),
				Тип("ПолеФормы"),
				ЭлементРодитель);
			
			ПолеНадписи.Вид                     = ВидПоляФормы.ПолеНадписи;
			ПолеНадписи.ПутьКДанным             = ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы);
			ПолеНадписи.ПоложениеЗаголовка      = ПоложениеЗаголовкаЭлементаФормы.Нет;
			ПолеНадписи.АвтоМаксимальнаяШирина  = Ложь;
			ПолеНадписи.АвтоМаксимальнаяВысота  = Ложь;
			ПолеНадписи.МаксимальнаяВысота      = 2;
			
			ПолеНадписи.УстановитьДействие(
				"ОбработкаНавигационнойСсылки",
				"Подключаемый_ПолеИнтеграцииИСОбработкаНавигационнойСсылки");
			
		КонецЦикла;
	КонецЕсли;
	
	ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект);
	
КонецПроцедуры

Процедура ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект, ДополнительныеПараметры = Неопределено)
	
	ИнтегрируемыеПодсистемы = ИнтеграцияИСКлиентСервер.ИнтегрируемыеПодсистемыВФормеДокументаОснования(Форма);
	
	Если НЕ ЗначениеЗаполнено(ИнтегрируемыеПодсистемы) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") И ДополнительныеПараметры.Свойство("ИмяПодсистемы") Тогда
		ИмяПодсистемыИзПараметров = ДополнительныеПараметры.ИмяПодсистемы;
	Иначе
		ИмяПодсистемыИзПараметров = Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ИнтегрируемыеПодсистемы Цикл
		
		ИмяПодсистемы = КлючИЗначение.Ключ;
		
		Если ЗначениеЗаполнено(ИмяПодсистемыИзПараметров) И ИмяПодсистемыИзПараметров <> ИмяПодсистемы Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПоляФормы = ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы);
		
		Если Форма.Элементы.Найти(ИмяПоляФормы) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Получим текст надписи на форме.
		ТекстНадписи = "<Удалить>";
		
		Форма[ИмяПоляФормы] = ТекстНадписи;
		Форма.Элементы[ИмяПоляФормы].Видимость = ЗначениеЗаполнено(ТекстНадписи);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ФормыДокументовИС

Процедура ПослеЗаписиНаСервереВФормеОбъектаДокументаИС(Форма, Объект, ИмяПодсистемы, ПараметрыЗаписи) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ПредыдущийДокументОснование") Тогда
		
		// Заполняется в подписках РассчитатьСтатусОформления[]ПередЗаписьюДокумента
		ПараметрыЗаписи.Вставить(
			"ПредыдущийДокументОснование",
			Объект.ДополнительныеСвойства.ПредыдущийДокументОснование);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура НастроитьВидимостьДокументаОснования(Форма) Экспорт
	
	Если Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма.Элементы, "ДокументОснование") Тогда
		Возврат;
	КонецЕсли;
	
	МассивИмен = СтрРазделить(Форма.ИмяФормы, ".");
	
	ЭтоФормаДокумента = Ложь;
	
	Пока МассивИмен.Количество() > 2 Цикл
		ЭтоФормаДокумента = ЭтоФормаДокумента ИЛИ МассивИмен[МассивИмен.ВГраница()] = "ФормаДокумента";
		МассивИмен.Удалить(МассивИмен.ВГраница());
	КонецЦикла;
	
	Если Не ЭтоФормаДокумента Тогда
		Возврат;
	КонецЕсли;
	
	ПолноеИмяМетаданных = СтрСоединить(МассивИмен, ".");
	ЭлементМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМетаданных);
	
	Если ЭлементМетаданных = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Реквизит = ЭлементМетаданных.Реквизиты.Найти("ДокументОснование");
	
	Если Реквизит = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТип Из Реквизит.Тип.Типы() Цикл
		Если Метаданные.НайтиПоТипу(СтрокаТип) <> Неопределено Тогда
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
	Форма.Элементы.ДокументОснование.Видимость = Ложь;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма.Элементы, "ТоварыПерезаполнитьПоОснованию") Тогда
		Форма.Элементы.ТоварыПерезаполнитьПоОснованию.Видимость = Ложь;
	КонецЕсли;
	
	Реквизит = Новый РеквизитФормы("НетМетаданныхОснования", Новый ОписаниеТипов("Булево"));
	
	МассивДобавляемыхРеквизитов = Новый Массив;
	МассивДобавляемыхРеквизитов.Добавить(Реквизит);
	
	Форма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
	Форма.НетМетаданныхОснования = Истина;
	
КонецПроцедуры

#КонецОбласти

#Область ДокументыИС

// Функция возвращает оформленные документы по документу-основанию
//   * в документе должен быть реквизит "ДокументОснование".
//   * допустимый тип документа определяется из регистра статусов.
// Параметры:
//  ДокументОснование					 - ДокументСсылка   - значение реквизита "ДокументОснование".
//  МетаданныеРегистраСтатусовДокументов - ОбъектМетаданных - используемый регистр статусов документов
//  ИмяИзмеренияДокумент                 - Строка           - используемое измерение регистра статусов документов
//  Фильтр                               - Строка           - фильтр регистра (при необходимости)
// Возвращаемое значение:
//  Структура - описание документов, где:
//   * Ключ - Строка - [ИмяДокумента], имя метаданных оформленного документа
//   * Значение - Массив Из Структура - массив структур с полями:
//     ** Ссылка - ДокументСсылка - ссылка на оформленный документ
//     ** Дата   - Дата           - дата документа
//     ** Статус - Произвольный   - статус документа по регистру
//
Функция ДокументыИСПоДокументуОснованию(ДокументОснование, МетаданныеРегистраСтатусовДокументов, 
		ИмяИзмеренияДокумент = "Документ", Фильтр = "") Экспорт
	
	ДокументыИС = Новый Структура;
	
	ИмяРегистра = МетаданныеРегистраСтатусовДокументов.Имя;
	МассивТекстов = Новый Массив;
	
	ШаблонВыборки =
	"ВЫБРАТЬ
	|	""%1""									КАК ИмяДокумента,
	|	Таблица.Ссылка							КАК Ссылка,
	|	Таблица.Дата							КАК Дата,
	|	ЕСТЬNULL(Статусы.Статус, НЕОПРЕДЕЛЕНО) 	КАК Статус
	|ИЗ
	|	Документ.%1 КАК Таблица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.%2 КАК Статусы
	|		ПО Статусы.%3 = Таблица.Ссылка
	|ГДЕ
	|	Таблица.ДокументОснование = &ДокументОснование
	|	И НЕ Таблица.ПометкаУдаления
	|	%4";
	
	ШаблонОбъединения = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|";
	
	Для Каждого ТипДокумента Из МетаданныеРегистраСтатусовДокументов.Измерения[ИмяИзмеренияДокумент].Тип.Типы() Цикл
		
		МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
		
		Если Не Метаданные.Документы.Содержит(МетаданныеДокумента) Тогда
			Продолжить;
		ИначеЕсли РеквизитДокументОснованиеДокументаИС(МетаданныеДокумента) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ДокументыИС.Вставить(МетаданныеДокумента.Имя, Новый Массив);
		МассивТекстов.Добавить(СтрШаблон(ШаблонВыборки, МетаданныеДокумента.Имя, ИмяРегистра, ИмяИзмеренияДокумент, Фильтр));
		
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(ДокументОснование) Тогда
		Возврат ДокументыИС;
	ИначеЕсли ДокументыИС.Количество() = 0 Тогда 
		Возврат ДокументыИС;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстов,ШаблонОбъединения);
	Запрос.УстановитьПараметр("ДокументОснование", ДокументОснование);
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	Пока Выборка.Следующий() Цикл
		
		ОписаниеДокумента = Новый Структура("Ссылка, Дата, Статус");
		ЗаполнитьЗначенияСвойств(ОписаниеДокумента, Выборка);
		
		ДокументыИС[Выборка.ИмяДокумента].Добавить(ОписаниеДокумента);
		
	КонецЦикла;
	
	Возврат ДокументыИС;
	
КонецФункции

#КонецОбласти

#Область МетаданныеИС

// Возвращает описание типов из указанного ссылочного типа по полному имени метаданных
//
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта для получения ссылочного типа
//
// Возвращаемое значение:
//   ОписаниеТипов
Функция ОписаниеТиповПоПолномуИмени(ПолноеИмя) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(ТипЗнч(МенеджерОбъекта.ПустаяСсылка()));
	Возврат Новый ОписаниеТипов(МассивТипов);
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - Тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов.
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
	
КонецФункции

// Возвращает менеджер (модуль менеджера или общий модуль) по полному имени метаданных
// 
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта для получения модуля менеджера.
//
// Возвращаемое значение:
//   СправочникМенеджер, ДокументМенеджер, ОбщийМодуль - менеджер объекта для библиотеки
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	МенеджерОбъекта = Неопределено;
	ИнтеграцияИСПереопределяемый.ПриОпределенииМенеджераОбъектаПоПолномуИмени(МенеджерОбъекта, ПолноеИмя);
	
	Если МенеджерОбъекта = Неопределено Тогда
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
	КонецЕсли;
	
	Возврат МенеджерОбъекта;
	
КонецФункции

// Возвращает менеджер (модуль менеджера или общий модуль) объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
// См. также ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ОбработкаМенеджер, РегистрСведенийМенеджер - менеджер объекта.
//
// Пример:
//  МенеджерСправочника = ОбщегоНазначения.МенеджерОбъектаПоСсылке(СсылкаНаОрганизацию);
//
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	МенеджерОбъекта = Неопределено;
	ИнтеграцияИСПереопределяемый.ПриОпределенииМенеджераОбъектаПоСсылке(МенеджерОбъекта, Ссылка);
	
	Если МенеджерОбъекта = Неопределено Тогда
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка);
	КонецЕсли;
	
	Возврат МенеджерОбъекта;
	
КонецФункции

Функция РеквизитДокументОснованиеДокументаИС(МетаданныеДокумента) Экспорт
	
	Возврат МетаданныеДокумента.Реквизиты.Найти("ДокументОснование");
	
КонецФункции

// Возвращает значение по умолчанию переданного определяемого типа.
// 
// Параметры:
//  ОпределяемыйТипИлиИмяТипа - Строка, ОбъектМетаданныхОпределяемыйТип - Определяемый тип или имя типа
// 
// Возвращаемое значение:
//  Произвольный, Неопределено - Пустое значение определяемого типа
Функция ПустоеЗначениеОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	// Обход ошибки платформы:
	// в некоторых случаях в фоновых заданиях для ссылочных типов определяемого типа
	// приведение значения выполняется не корректно
	// Справочники.СерииНоменклатуры.ПустаяСсылка() <> ОпределяемыеТипы().СерияНоменклатуры.Тип.ПривестиЗначение()
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = ОпределяемыеТипы()[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	ТипыОпределяемогоТипа = ОпределяемыйТип.Тип.Типы();
	
	Если ТипыОпределяемогоТипа.Количество() = 1 Тогда
		
		ТипОпределяемогоТипа = ТипыОпределяемогоТипа[0];
		
		Если ТипОпределяемогоТипа = Неопределено Тогда
			Возврат Неопределено;
		ИначеЕсли ОбщегоНазначения.ЭтоСсылка(ТипОпределяемогоТипа) Тогда
			Возврат Новый (ТипОпределяемогоТипа)
		КонецЕсли;
		
		Возврат ОпределяемыйТип.Тип.ПривестиЗначение();
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Формирует массив пустых значений определяемого типа.
// 
// Возвращаемое значение:
//  Массив - Пустые значения определяемого типа.
//
Функция НезаполненныеЗначенияОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = ОпределяемыеТипы()[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	МассивПустыхЗначений = Новый Массив;
	Для Каждого ТипЗначения Из ОпределяемыйТип.Тип.Типы() Цикл
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(ТипЗначения);
		ОписаниеТипа = Новый ОписаниеТипов(МассивТипов);
		МассивПустыхЗначений.Добавить(ОписаниеТипа.ПривестиЗначение());
	КонецЦикла;
	
	Если МассивПустыхЗначений.Количество() > 1 Тогда
		МассивПустыхЗначений.Добавить(Неопределено);
	КонецЕсли;
	
	Возврат МассивПустыхЗначений;
	
КонецФункции

// Проверяет наличие права изменения документов определяемого типа у текущего пользователя.
//
// Возвращаемое значение:
//  Булево - Истина, если есть право изменения хотя бы одного документа, Ложь в обратном случае.
//
Функция ПравоИзмененияДокументовИзОпределяемогоТипа(ОпределяемыйТип) Экспорт

	Для Каждого ВозможныйТип Из ОпределяемыйТип.Тип.Типы() Цикл
		МетаданныеТипа = Метаданные.НайтиПоТипу(ВозможныйТип);
		Если МетаданныеТипа <> Неопределено Тогда
			Если ПравоДоступа("Изменение", МетаданныеТипа) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;

КонецФункции

Функция ПодсистемаСуществует(КраткоеИмяПодсистемы)
	
	ПолноеИмяПодсистемы = ИнтеграцияИСКлиентСервер.ПолноеИмяПодсистемы(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ПодсистемаСуществует(ПолноеИмяПодсистемы);
	
КонецФункции

Функция ОбщийМодуль(КраткоеИмяПодсистемы)
	
	ИмяМодуля = ИнтеграцияИСКлиентСервер.МодульСервер(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ОбщийМодуль(ИмяМодуля);
	
КонецФункции

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - Строковое имя искомого реквизита.
//  МетаданныеОбъекта - ОбъектМетаданных - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - Строка - Строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево - Истина, нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ПодготовкаИЗаписьДвиженийДокумента

// Расчет статусов оформления для документов-оснований выполняется вне транзакции записи.
// Если записываемый объект не является документом-основанием, расчет по текущему документу будет выполнен сразу.
// 
// Возвращаемое значение:
//  Булево - расчет статусов оформления вынесен из подписок записи документов
Функция РасчетСтатусовОформленияВыполняетсяВнеТранзакцииЗаписи() Экспорт
	
	РасчетОтдельно = Ложь;
	ИнтеграцияИСПереопределяемый.НастроитьСпособРасчетаСтатусовОформления(РасчетОтдельно);
	Возврат РасчетОтдельно;
	
КонецФункции

// Определяет необходимость подготовить таблицу для формирования движений
//
// Параметры:
//  ИмяРегистра - Строка - имя регистра. Например "ТоварыНаСкладах"
//  Регистры    - Строка, Структура - список регистров, разделенных запятой, или структура, в ключах которой - имена регистров
//              - Неопределено - то всегда возвращается ИСТИНА
// 
// Возвращаемое значение:
//  Булево - Истина, если требуется инициализировать указанную таблицу
//
Функция ТребуетсяТаблицаДляДвижений(ИмяРегистра, Регистры) Экспорт

	Если ЗначениеЗаполнено(Регистры) Тогда
		
		Если ТипЗнч(Регистры) = Тип("Строка") Тогда
			МассивРегистров = Новый Структура(Регистры);
		Иначе
			МассивРегистров = Регистры;
		КонецЕсли;
		
		Если НЕ МассивРегистров.Свойство(ИмяРегистра) Тогда
			Возврат Ложь;
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат Истина;

КонецФункции

// Процедура инициализирует общие структуры, используемые при проведении документов.
// Вызывается из модуля документов при проведении.
//
Процедура ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументСсылка, ДополнительныеСвойства, РежимПроведения = Неопределено) Экспорт

	// В структуре "ДополнительныеСвойства" создаются свойства с ключами "ТаблицыДляДвижений", "ДляПроведения".

	// "ТаблицыДляДвижений" - структура, которая будет содержать таблицы значений с данными для выполнения движений.
	ДополнительныеСвойства.Вставить("ТаблицыДляДвижений", Новый Структура);

	// "ДляПроведения" - структура, содержащая свойства и реквизиты документа, необходимые для проведения.
	ДополнительныеСвойства.Вставить("ДляПроведения", Новый Структура);
	
	// Структура, содержащая ключ с именем "МенеджерВременныхТаблиц", в значении которого хранится менеджер временных таблиц.
	// Содержит для каждой временной таблицы ключ (имя временной таблицы) и значение (признак наличия записей во временной таблице).
	ДополнительныеСвойства.ДляПроведения.Вставить("СтруктураВременныеТаблицы", Новый Структура("МенеджерВременныхТаблиц", Новый МенеджерВременныхТаблиц));
	ДополнительныеСвойства.ДляПроведения.Вставить("РежимПроведения",           РежимПроведения);
	ДополнительныеСвойства.ДляПроведения.Вставить("МетаданныеДокумента",       ДокументСсылка.Метаданные());
	ДополнительныеСвойства.ДляПроведения.Вставить("Ссылка",                    ДокументСсылка);
	
КонецПроцедуры

// Процедура компонует текст запроса, выполняет запрос и выгружает результаты запроса в таблицы
// 
// Параметры:
//  Запрос - Запрос - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса - СписокЗначений из Строка - в списке перечислены тексты запросов и их имена.
//  Таблицы - Структура - структура в которую будут помещены полученные таблицы для движений.
//  ДобавитьРазделитель - Булево - Истина, если нужно добавить разделитель ";" между запросами.
//  ДобавлятьСловоТаблица - Булево - Истина, если к имени таблицы движений нужно в начало добавить слово "Таблица"
//  ТолькоОтмеченные - Булево - Только отмеченные регистры
Процедура ИнициализироватьТаблицыДляДвижений(Запрос, ТекстыЗапроса, Таблицы, ДобавитьРазделитель = Ложь, ДобавлятьСловоТаблица = Истина, ТолькоОтмеченные=Ложь) Экспорт
	
	ТаблицыЗапроса = ВыгрузитьРезультатыЗапроса(Запрос, ТекстыЗапроса,, ДобавитьРазделитель);
	
	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл

		ИмяТаблицы = ТекстЗапроса.Представление;

		Если Не ПустаяСтрока(ИмяТаблицы) И (Не ТолькоОтмеченные Или ТекстЗапроса.Пометка) Тогда

			Если ДобавлятьСловоТаблица Тогда
				// Таблицы для проведения должны начинаться с "Таблица"
				Если НЕ СтрНачинаетсяС(ИмяТаблицы, "Таблица") Тогда
					ИмяТаблицы = "Таблица" + ИмяТаблицы;
				КонецЕсли;
			КонецЕсли;
			
			Таблицы.Вставить(ИмяТаблицы, ТаблицыЗапроса[ТекстЗапроса.Представление]);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Формирует пакет запросов и возвращает результат каждого запроса
// 
// Параметры:
//  Запрос - Запрос - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса - СписокЗначений из Строка - в списке перечислены тексты запросов и их имена.
//  ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//  ДобавитьРазделитель - Булево - Добавить разделитель
// 
// Возвращаемое значение:
//  Структура -- структура в которую помещены полученные таблицы
Функция ВыгрузитьРезультатыЗапроса(Запрос, ТекстыЗапроса, ОбходРезультата = Неопределено, ДобавитьРазделитель = Ложь)

	Таблицы = Новый Структура;
	
	Если ТекстыЗапроса.Количество() = 0 Тогда
		Возврат Таблицы;
	КонецЕсли;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	МассивТекстаЗапроса = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстаЗапроса.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли; 
		МассивТекстаЗапроса.Добавить(ТекстЗапроса.Значение);
		Если ДобавитьРазделитель Тогда
			МассивТекстаЗапроса.Добавить("
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|");
		КонецЕсли;
	КонецЦикла;
	
	Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Символы.ПС);
	
	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл

		ИмяТаблицы = ТекстЗапроса.Представление;

		Если Не ПустаяСтрока(ИмяТаблицы) Тогда

			Индекс = ТекстыЗапроса.Индекс(ТекстЗапроса);
			Таблицы.Вставить(ИмяТаблицы, Результат[Индекс].Выгрузить(ОбходРезультата));

		КонецЕсли;

	КонецЦикла;

	Возврат Таблицы;
	
КонецФункции

// Процедура выполняет подготовку наборов записей документа к записи движений.
// 1. Очищает наборы записей от "старых записей" (ситуация возможна только в толстом клиенте)
// 2. Взводит флаг записи у наборов, по которым документ имеет движения
// Вызывается из модуля документов при проведении.
//
Процедура ПодготовитьНаборыЗаписейКРегистрацииДвижений(Объект, ЭтоНовый = Ложь) Экспорт
	Перем ЭтоНовыйДокумент, МетаданныеДвижения;
	
	Для Каждого НаборЗаписей Из Объект.Движения Цикл

		Если НаборЗаписей.Количество() > 0 Тогда
			НаборЗаписей.Очистить();
		КонецЕсли;

	КонецЦикла;
	
	Если НЕ Объект.ДополнительныеСвойства.Свойство("ЭтоНовый", ЭтоНовыйДокумент) Тогда
		ЭтоНовыйДокумент = ЭтоНовый;
	КонецЕсли;
	
	Если НЕ ЭтоНовыйДокумент Тогда

		Если Объект.ДополнительныеСвойства.Свойство("ДляПроведения")
		 И Объект.ДополнительныеСвойства.ДляПроведения.Свойство("МетаданныеДокумента") Тогда
			МетаданныеДвижения = Объект.ДополнительныеСвойства.ДляПроведения.МетаданныеДокумента.Движения;
		Иначе
			МетаданныеДвижения = Объект.Метаданные().Движения;
		КонецЕсли;
		
		МассивИменРегистров = ПолучитьИспользуемыеРегистры(Объект.Ссылка, МетаданныеДвижения);

		Для Каждого ИмяРегистра Из МассивИменРегистров Цикл
			Объект.Движения[ИмяРегистра].Записывать = Истина;
		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

// Функция формирует массив имен регистров, по которым документ имеет движения.
// Вызывается при подготовке записей к регистрации движений.
//
Функция ПолучитьИспользуемыеРегистры(Регистратор, Движения, МассивИсключаемыхРегистров = Неопределено)

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Регистратор", Регистратор);

	Результат = Новый Массив;
	МаксимумТаблицВЗапросе = 256;

	СчетчикТаблиц   = 0;
	СчетчикДвижений = 0;

	ВсегоДвижений = Движения.Количество();
	МассивТекстаЗапроса = Новый Массив;
	
	Разделитель = 
	"
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	Для Каждого Движение Из Движения Цикл

		СчетчикДвижений = СчетчикДвижений + 1;

		ПропуститьРегистр = МассивИсключаемыхРегистров <> Неопределено
							И МассивИсключаемыхРегистров.Найти(Движение.Имя) <> Неопределено;

		Если Не ПропуститьРегистр Тогда

			СчетчикТаблиц = СчетчикТаблиц + 1;

			МассивТекстаЗапроса.Добавить(
			"
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|""" + Движение.Имя + """ КАК ИмяРегистра
			|
			|ИЗ " + Движение.ПолноеИмя() + "
			|
			|ГДЕ Регистратор = &Регистратор
			|");

		КонецЕсли;

		Если СчетчикТаблиц = МаксимумТаблицВЗапросе Или СчетчикДвижений = ВсегоДвижений Тогда

			Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Разделитель);
			МассивТекстаЗапроса.Очистить();
			
			СчетчикТаблиц = 0;

			Если Результат.Количество() = 0 Тогда

				Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ИмяРегистра");

			Иначе

				Выборка = Запрос.Выполнить().Выбрать();
				Пока Выборка.Следующий() Цикл
					Результат.Добавить(Выборка.ИмяРегистра);
				КонецЦикла;

			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Процедура записывает движения документа. Дополнительно происходит копирование параметров
// в модули наборов записей для выполнения регистрации изменений в движениях.
// Процедура вызывается из модуля документов при проведении.
//
Процедура ЗаписатьНаборыЗаписей(Объект) Экспорт
	Перем РегистрыДляКонтроля, РассчитыватьИзменения;
	
	Для Каждого Движение Из Объект.Движения Цикл
		
		Движение.ДополнительныеСвойства.Вставить("ЭтоНовый", Объект.ДополнительныеСвойства.ЭтоНовый);
		Движение.ДополнительныеСвойства.Вставить("РежимЗаписи", Объект.ДополнительныеСвойства.РежимЗаписи);
		Движение.ДополнительныеСвойства.Вставить("ДатаРегистратора", Объект.Дата);
		
		Движение.ДополнительныеСвойства.Вставить("ДляПроведения", 
			Новый Структура("СтруктураВременныеТаблицы",
				// Структура для передачи данных в модули наборов записей.
				Объект.ДополнительныеСвойства.ДляПроведения.СтруктураВременныеТаблицы));
		
	КонецЦикла;
	
	// Регистры, для которых будут рассчитаны таблицы изменений движений.
	Если Объект.ДополнительныеСвойства.ДляПроведения.Свойство("РегистрыДляКонтроля", РегистрыДляКонтроля) Тогда
		
		// Установка флага регистрации изменений в наборе записей.
		Если НЕ Объект.ДополнительныеСвойства.Свойство("РассчитыватьИзменения", РассчитыватьИзменения) Тогда
			РассчитыватьИзменения = Истина;
		КонецЕсли;
		
		Для Каждого НаборЗаписей Из РегистрыДляКонтроля Цикл
			Если НаборЗаписей.Записывать Тогда
				
				НаборЗаписей.ДополнительныеСвойства.Вставить("РассчитыватьИзменения", РассчитыватьИзменения);
				
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;
	
	Объект.Движения.Записать();
	
КонецПроцедуры

// Выполняет закрытие менеджера временных таблиц в структуре дополнительных свойств документа, используемых 
// при проведении.
//
// Параметры:
//	ДополнительныеСвойства - Структура - структура с дополнительными свойствами документа, используемыми
//		при проведении.
//
Процедура ОчиститьДополнительныеСвойстваДляПроведения(ДополнительныеСвойства) Экспорт

	ДополнительныеСвойства.ДляПроведения.СтруктураВременныеТаблицы.МенеджерВременныхТаблиц.Закрыть();

КонецПроцедуры

#КонецОбласти

#Область ПрисоединенныеФайлы

// Получает текст сообщения XML из присоединенного файла, в котором хранится сообщение протокола обмена.
//
// Параметры:
//  Сообщение - ОпределяемыйТип.ПрисоединенныйФайл, Строка - хранимый файл сообщения, из которого извлекается текст сообщения XML.
// 
// Возвращаемое значение:
//  Строка - полученный текст сообщения XML.
//
Функция ТекстСообщенияXMLИзПротокола(Сообщение) Экспорт
	
	Если ТипЗнч(Сообщение) = Тип("Строка") Тогда
		Возврат Сообщение;
	КонецЕсли;
	
	ДвоичныеДанные = РаботаСФайлами.ДвоичныеДанныеФайла(Сообщение);
	Если ДвоичныеДанные = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные.Записать(ИмяВременногоФайла);
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ИмяВременногоФайла, КодировкаТекста.UTF8, "");
	ТекстСообщенияXML = ТекстовыйДокумент.ПолучитьТекст();
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайла);
	Исключение
		ИнтеграцияИСВызовСервера.ЗаписатьОшибкуВЖурналРегистрации(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ТекстСообщенияXML;
	
КонецФункции

// Добавить запись в протокол обмена.
//
// Параметры:
//   Протокол              - ОбъектМетаданныхСправочник - протокол обмена
//   ТекстСообщенияXML     - Строка                     - Текст сообщения XML.
//   Реквизиты - Структура                              - Значения реквизитов сообщения, с обязательными полями:
//    * Документ       - Произвольный - документ по которому ведется протокол обмена,
//    * ВладелецФайлов - Произвольный - элемент по которому ведется обмен с ГосИС.
//   ПроверятьХешБезСсылки - Булево                     - Признак проверки хеша без ссылки.
//   ЗаписатьПринудительно - Булево                     - Признак записи сообщения без поиска по хешу.
// Возвращаемое значение:
//   Структура - Структура со свойствами:
//    * НовоеСообщение - Булево - Это новое сообщение.
//    * Ссылка - СправочникСсылка - Ссылка на присоединенный файл (СправочникСсылка[Протокол.Имя]).
//
Функция ДобавитьЗаписьВПротоколОбмена(Протокол, ТекстСообщенияXML, Реквизиты, ПроверятьХешБезСсылки, ЗаписатьПринудительно = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ЗаписатьПринудительно Тогда
		
		ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
		ХешированиеДанныхОбъект.Добавить(ТекстСообщенияXML);
		ХешСуммаBase64 = Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
		
		Если ПроверятьХешБезСсылки Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Протокол.Ссылка КАК Ссылка,
			|	Протокол.Документ КАК Документ
			|ИЗ
			|	&Протокол КАК Протокол
			|ГДЕ
			|	Протокол.ХешСумма = &ХешСумма
			|	И Протокол.Документ ССЫЛКА &ИмяТаблицы");
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Протокол",   Протокол.ПолноеИмя());
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицы", Реквизиты.Документ.Метаданные().ПолноеИмя());
			Запрос.УстановитьПараметр("ХешСумма", ХешСуммаBase64);
			
		Иначе
			
			СообщениеОснование = Справочники[Протокол.Имя].ПустаяСсылка();
			Если Реквизиты.Свойство("СообщениеОснование") Тогда
				СообщениеОснование = Реквизиты.СообщениеОснование;
			КонецЕсли;
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Протокол.Ссылка КАК Ссылка,
			|	Протокол.Документ КАК Документ
			|ИЗ
			|	&Протокол КАК Протокол
			|ГДЕ
			|	Протокол.Документ = &Документ
			|	И Протокол.СообщениеОснование = &СообщениеОснование
			|	И Протокол.ХешСумма = &ХешСумма");
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Протокол",   Протокол.ПолноеИмя());
			Запрос.УстановитьПараметр("Документ",           Реквизиты.Документ);
			Запрос.УстановитьПараметр("ХешСумма",           ХешСуммаBase64);
			Запрос.УстановитьПараметр("СообщениеОснование", СообщениеОснование);
			
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		
	КонецЕсли;
	
	ДокументОснование = Неопределено;
	
	Если Выборка <> Неопределено
		И Выборка.Следующий() Тогда
		
		НовоеСообщение = Ложь;
		
		Ссылка   = Выборка.Ссылка;
		Документ = Выборка.Документ;
		
		Если ЗначениеЗаполнено(Выборка.Документ)
			И Выборка.Документ.Метаданные().Реквизиты.Найти("ДокументОснование") <> Неопределено Тогда
			ДокументОснование = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Выборка.Документ, "ДокументОснование");
		КонецЕсли;
		
	Иначе
		
		НовоеСообщение = Истина;
		ДвоичныеДанные = ПолучитьДвоичныеДанныеИзСтроки(ТекстСообщенияXML, КодировкаТекста.UTF8);
		АдресФайлаВоВременномХранилище = ПоместитьВоВременноеХранилище(ДвоичныеДанные);
		
		ПараметрыФайла = Новый Структура();
		ПараметрыФайла.Вставить("Автор",              Пользователи.АвторизованныйПользователь());
		ПараметрыФайла.Вставить("ВладелецФайлов",     Реквизиты.ВладелецФайлов);
		ПараметрыФайла.Вставить("ИмяБезРасширения",   Строка(Новый УникальныйИдентификатор));
		ПараметрыФайла.Вставить("РасширениеБезТочки", "xml");
		ПараметрыФайла.Вставить("ВремяИзмененияУниверсальное");
		
		ПрисоединенныйФайл = РаботаСФайлами.ДобавитьФайл(
			ПараметрыФайла,
			АдресФайлаВоВременномХранилище,,,
			Справочники[Протокол.Имя].ПолучитьСсылку());
		
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ПрисоединенныйФайлОбъект.ХешСумма = ХешСуммаBase64;
		
		ЗаполнитьЗначенияСвойств(ПрисоединенныйФайлОбъект, Реквизиты);
		
		ПрисоединенныйФайлОбъект.Записать();
		
		Ссылка   = ПрисоединенныйФайлОбъект.Ссылка;
		Документ = ПрисоединенныйФайлОбъект.Документ;
		
	КонецЕсли;
	
	ВозвращаемоеЗначение = Новый Структура;
	ВозвращаемоеЗначение.Вставить("НовоеСообщение",    НовоеСообщение);
	ВозвращаемоеЗначение.Вставить("Ссылка",            Ссылка);
	ВозвращаемоеЗначение.Вставить("Документ",          Документ);
	ВозвращаемоеЗначение.Вставить("ДокументОснование", ДокументОснование);
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

// Вызывает исключение при открытии формы протокола обмена с незаполненным параметром "Документ"
//  (форма предназначается для просмотра протокола обмена по конкретному объекту).
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - форма протокола обмена
//
Процедура ОтработатьВходящийДокументПротоколаОбмена(Форма, ИмяПоляДокумент = "Документ", ИмяРеквизита = "Документ") Экспорт
	
	Если ЗначениеЗаполнено(Форма.Параметры[ИмяПоляДокумент]) Тогда
		Форма[ИмяРеквизита] = Форма.Параметры[ИмяПоляДокумент];
	Иначе
		ВызватьИсключение НСтр("ru = 'Протокол обмена может быть открыт только в контексте документа.'");
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает типовое условное оформление протокола обмена
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения - форма протокола обмена
//
Процедура УстановитьУсловноеОформлениеПротоколаОбмена(Форма) Экспорт
	
	УсловноеОформление = Форма.УсловноеОформление;
	Элементы = Форма.Элементы;
	
	УсловноеОформление.Элементы.Очистить();
	
#Область ДеревоЗачеркнутый
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеЗачеркнутый";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(,,,,,Истина));
	
#КонецОбласти

#Область ДеревоСерый

	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеСерый";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаНеТребуетВниманияГосИС);
	
#КонецОбласти

#Область ДеревоЖирный

	Элемент = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);

	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеЖирный";

	Элемент.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(,,Истина));
	
#КонецОбласти

#Область ДеревоОтказ
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеОшибка";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.СтатусОбработкиОшибкаПередачиГосИС);
	
#КонецОбласти

#Область ДатаНеПередана
	
	СтандартныеПодсистемыСервер.УстановитьУсловноеОформлениеПоляДата(Форма, "ДеревоФайлов.Дата", Элементы.ДеревоФайловДата.Имя);
	
	// Представление даты "<не передано>"
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();
	ЭлементУсловногоОформления.Использование = Истина;
	
	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ДеревоФайловДата");
	
	ПредставлениеЭлемента = НСтр("ru = 'Представление даты ""<не передано>""'");
	ЭлементУсловногоОформления.Представление = ПредставлениеЭлемента;
	
	ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ДеревоФайлов.Дата");
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = '00010101';
	ЭлементОтбораДанных.Использование = Истина;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = '<не передано>'"));
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаНеТребуетВниманияГосИС);
	
#КонецОбласти

КонецПроцедуры

// Возвращает индекс картинки запроса в коллекции "ПротоколОбменаИС"
//
// Параметры:
//  СтрокаПоследовательности - Произвольный - коллекция с типом запроса (входящий, исходящий)
//  НеВыполнен				 - Булево - серые стрелки (по умолчанию Ложь)
// 
// Возвращаемое значение:
//  Число - индекс соответствующей картинки запроса
//
Функция ИндексКартинкиЗапроса(СтрокаПоследовательности, НеВыполнен = Ложь) Экспорт
	
	ИндексКартинки = 0;
	
	Смещение = 0;
	Если НеВыполнен Тогда
		Смещение = 6;
	КонецЕсли;
	
	Если СтрокаПоследовательности = Неопределено Тогда
	ИначеЕсли СтрокаПоследовательности.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
		ИндексКартинки = 1 + Смещение;
	ИначеЕсли СтрокаПоследовательности.ТипСообщения = Перечисления.ТипыЗапросовИС.Входящий Тогда
		ИндексКартинки = 2 + Смещение;
	КонецЕсли;
	
	Возврат ИндексКартинки;
	
КонецФункции

#КонецОбласти

#Область ПоследовательностьСообщений

// Создает таблицу последовательности операций.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с колонками:
//   * Операция - ПеречислениеСсылка.ВидыОперацийВЕТИС, ПеречислениеСсылка.ВидыОперацийИСМП - Операция.
//   * Индекс - Число - Индекс операции в последовательности.
//   * ТипСообщения - ПеречислениеСсылка.ТипыЗапросовИС - Тип сообщения.
//   * ДальнейшиеДействия - Массив Из ПеречислениеСсылка - Дальнейшие действия при операции.
//
Функция ПустаяТаблицаПоследовательностьОпераций() Экспорт
	
	ПоследовательностьОпераций = Новый ТаблицаЗначений;
	
	ПоследовательностьОпераций.Колонки.Добавить("Операция");
	ПоследовательностьОпераций.Колонки.Добавить("Индекс");
	ПоследовательностьОпераций.Колонки.Добавить("ТипСообщения");
	ПоследовательностьОпераций.Колонки.Добавить("ДальнейшиеДействия");
	ПоследовательностьОпераций.Колонки.Добавить("АбстрактнаяОперация", Новый ОписаниеТипов("Булево"));
	
	Возврат ПоследовательностьОпераций;
	
КонецФункции

// Возвращает предыдущую операцию последовательности операций.
//
// Параметры:
//  ПоследовательностьОпераций - ТаблицаЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//  СтрокаПоследовательности - СтрокаТаблицыЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//  ИсходныйИндекс - Число - Индекс текущей операции.
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//
Функция ПредыдущаяОперация(ПоследовательностьОпераций, СтрокаПоследовательности, Знач ИсходныйИндекс = Неопределено) Экспорт
	
	ИндексСтроки = ПоследовательностьОпераций.Индекс(СтрокаПоследовательности);
	
	Если ИндексСтроки = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПредыдущаяОперация = ПоследовательностьОпераций.Получить(ИндексСтроки - 1);
	
	Если ИсходныйИндекс = Неопределено Тогда
		ИсходныйИндекс = СтрокаПоследовательности.Индекс;
	КонецЕсли;
	
	// Пропускаем абстрактные операции
	Если ПредыдущаяОперация.АбстрактнаяОперация Тогда
		Возврат ПредыдущаяОперация(ПоследовательностьОпераций, ПредыдущаяОперация, ИсходныйИндекс);
	КонецЕсли;
	
	АнализироватьПредыдущуюОперацию = ПроверитьИндекс(
		Формат(ПредыдущаяОперация.Индекс, "ЧГ=0;ЧН=0"),
		Формат(ИсходныйИндекс, "ЧГ=0;ЧН=0"));
	
	Если АнализироватьПредыдущуюОперацию
		И ПредыдущаяОперация.Индекс <> 0 Тогда
		Возврат ПредыдущаяОперация(ПоследовательностьОпераций, ПредыдущаяОперация, ИсходныйИндекс);
	КонецЕсли;
	
	Возврат ПредыдущаяОперация;
	
КонецФункции

// Добавляет операцию в последовательность операций.
//
// Параметры:
//  ПоследовательностьОпераций - см. ПустаяТаблицаПоследовательностьОпераций.
//  Индекс - Число - Индекс добавляемой операции.
//  ТипСообщения - ПеречислениеСсылка.ТипыЗапросовИС - Тип сообщения.
//  Операция - ПеречислениеСсылка.ВидыОперацийВЕТИС, ПеречислениеСсылка.ВидыОперацийИСМП - Операция.
//  РассчитатьДействияДляДокумента - ДокументСсылка - Документ, для которого нужно вычислить дальнейшие действия.
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//
Функция ДобавитьОперациюВПоследовательность(ПоследовательностьОпераций,
			Индекс, ТипСообщения, Операция, РассчитатьДействияДляДокумента = Неопределено) Экспорт

	НоваяСтрока = ПоследовательностьОпераций.Добавить();
	НоваяСтрока.Операция           = Операция;
	НоваяСтрока.Индекс             = Индекс;
	НоваяСтрока.ТипСообщения       = ТипСообщения;
	НоваяСтрока.ДальнейшиеДействия = Новый Массив;
	
	Если ЗначениеЗаполнено(РассчитатьДействияДляДокумента) Тогда
		
		ПолноеИмя = РассчитатьДействияДляДокумента.Метаданные().ПолноеИмя();
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
		
		Если ПоследовательностьОпераций.Количество() = 1 Тогда
			
			НоваяСтрока.ДальнейшиеДействия.Добавить(МенеджерОбъекта.ДальнейшееДействиеПоУмолчанию());
			
		Иначе
			
			ПредыдущаяОперация = ПредыдущаяОперация(ПоследовательностьОпераций, НоваяСтрока);
			
			Если ПредыдущаяОперация = Неопределено Тогда
				
				НоваяСтрока.ДальнейшиеДействия.Добавить(МенеджерОбъекта.ДальнейшееДействиеПоУмолчанию());
				
			Иначе
				
				Если ПредыдущаяОперация.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
					Статусы = МенеджерОбъекта.СтатусПослеПередачиДанных(
						РассчитатьДействияДляДокумента,
						ПредыдущаяОперация.Операция,
						Неопределено);
				Иначе
					Статусы = МенеджерОбъекта.СтатусПослеПолученияДанных(
						РассчитатьДействияДляДокумента,
						ПредыдущаяОперация.Операция);
				КонецЕсли;
				
				Если Статусы.Количество() Тогда
					МенеджерСтатусов = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Статусы[0]);
					НоваяСтрока.ДальнейшиеДействия = МенеджерСтатусов.ДальнейшиеДействия(Статусы);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат НоваяСтрока;
	
КонецФункции

// Выполняет отмену операции.
// 
// Параметры:
// 	ДокументСсылка - ДокументСсылка - Ссылка на документ, операцию которого необходимо отменить.
// 	ДанныеПоследнегоСообщения - Структура - Данные последнего сообщения, например структура, возвращаемая функцией См. Справочники.ЕГАИСПрисоединенныеФайлы.ПоследнееСообщение.
// Возвращаемое значение:
// 	Неопределено - Описание
Функция ОтменитьОперацию(ДокументСсылка, ДанныеПоследнегоСообщения) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(ДокументСсылка);
	ПоследовательностьОпераций = МенеджерОбъекта.ПоследовательностьОпераций(ДокументСсылка);
	
	СтрокаПоследовательности = ПоследовательностьОпераций.Найти(ДанныеПоследнегоСообщения.Операция, "Операция");
	
	ПредыдущаяОперация = ИнтеграцияИС.ПредыдущаяОперация(ПоследовательностьОпераций, СтрокаПоследовательности);
	Если ПредыдущаяОперация = Неопределено Тогда
		
		НовыйСтатусПослеОбновления = МенеджерОбъекта.ОбновитьСтатус(
			ДокументСсылка, Неопределено, Неопределено);
		
	Иначе
		
		Если ПредыдущаяОперация.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
			ПараметрыОбновления = МенеджерОбъекта.СтатусПослеПередачиДанных(
				ДокументСсылка,
				ПредыдущаяОперация.Операция,
				Неопределено);
		Иначе
			ПараметрыОбновления = МенеджерОбъекта.СтатусПослеПолученияДанных(
				ДокументСсылка,
				ПредыдущаяОперация.Операция,
				Неопределено);
		КонецЕсли;
		
		Если ПараметрыОбновления = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		НовыйСтатусПослеОбновления = МенеджерОбъекта.ОбновитьСтатус(
			ДокументСсылка,
			ПараметрыОбновления,
			Неопределено);
		
	КонецЕсли;
	
	Возврат НовыйСтатусПослеОбновления;
	
КонецФункции

#КонецОбласти

#Область СправочникиИКлассификаторы

// Дополняет список странами ЕАЭС
// 
// Параметры:
//  СписокСтран - СписокЗначений - текущий список стран
//  ВключатьКодВПредставление - Булево - Включает в представление код страны.
Процедура ДополнитьСписокСтранЕАЭС(СписокСтран, ВключатьКодВПредставление = Истина) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	КлассификаторСтранМира.Ссылка                КАК Ссылка,
		|	КлассификаторСтранМира.Код                   КАК Код,
		|	Представление(КлассификаторСтранМира.Ссылка) КАК Представление
		|ИЗ
		|	Справочник.КлассификаторСтранМира КАК КлассификаторСтранМира
		|ГДЕ
		|	КлассификаторСтранМира.УчастникЕАЭС
		|	И НЕ КлассификаторСтранМира.ПометкаУдаления
		|УПОРЯДОЧИТЬ ПО
		|	Код";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Если СписокСтран.НайтиПоЗначению(ВыборкаДетальныеЗаписи.Ссылка) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ВключатьКодВПредставление Тогда
			Представление = СтрШаблон("%1 - %2", ВыборкаДетальныеЗаписи.Код, ВыборкаДетальныеЗаписи.Представление);
		Иначе
			Представление = ВыборкаДетальныеЗаписи.Представление;
		КонецЕсли;
		СписокСтран.Добавить(ВыборкаДетальныеЗаписи.Ссылка, Представление);
	КонецЦикла;
	
КонецПроцедуры

// Переопределяется список и настройки классификаторов обновления которых необходимо
// загружать из сервиса классификаторов. Для получения идентификатора необходимо
// перевести наименование объекта метаданных, данные которого планируется обновлять,
// на английский язык. При переводе рекомендуется использовать профессиональные
// программы перевода текста, либо воспользоваться услугами переводчика, т.к. при
// обнаружении смысловых ошибок в идентификаторе потребуется заводить новый классификатор
// и изменять код конфигурации.
//
// Параметры:
//  Классификаторы  - Массив из Структура - содержит настройки загрузки классификаторов.
//                    Состав настроек см. функцию РаботаСКлассификаторами.ОписаниеКлассификатора.
//
// Пример:
//	Описатель = РаботаСКлассификаторами.ОписаниеКлассификатора();
//	Описатель.Наименование               = НСтр("ru = 'Ставки рефинансирования'");
//	Описатель.Идентификатор              = "CentralBankRefinancingRate";
//	Описатель.ОбновлятьАвтоматически     = Истина;
//	Описатель.ОбщиеДанные                = Истина;
//	Описатель.СохранятьФайлВКэш          = Ложь;
//	Описатель.ОбработкаРазделенныхДанных = Ложь;
//	Классификаторы.Добавить(Описатель);
//
//@skip-warning
Процедура ПриДобавленииКлассификаторов(Классификаторы) Экспорт
	
	Если ПодсистемаСуществует("ЗЕРНО") Тогда
		МодульИнтеграцияЗЕРНО = ОбщийМодуль("ЗЕРНО");
		МодульИнтеграцияЗЕРНО.ПриДобавленииКлассификаторов(Классификаторы);
	КонецЕсли;
	
	Если ПодсистемаСуществует("ВетИС") Тогда
		МодульИнтеграцияВЕТИС = ОбщийМодуль("ВЕТИС");
		МодульИнтеграцияВЕТИС.ПриДобавленииКлассификаторов(Классификаторы);
	КонецЕсли;
	
КонецПроцедуры

// Переопределяются номер версии классификатора, который уже загружен в информационную базу.
// При начале использовании подсистемы "РаботаСКлассификаторами" или при подключении нового
// классификатора к сервису, неизвестно какой номер версии классификатора загружен в ИБ,
// поэтому при очередной итерации обновления данных из сервиса данные будут загружены повторно.
// Чтобы избежать повторной загрузки, необходимо указать задать начальный номер версии.
// Метод будет вызван при попытке загрузить версию классификатора, у которого установлена
// версия равная 0.
//
// Параметры:
//  Идентификатор        - Строка - идентификатор классификатора в сервисе классификаторов.
//                         Определяется в процедуре ПриДобавленииКлассификаторов.
//  НачальныйНомерВерсии - Число - номер версии загруженного классификатора.
//
// Пример:
//	Если Идентификатор = "CentralBankRefinancingRate" Тогда
//		НачальныйНомерВерсии = РегистрыСведений.СтавкиРефинансирования.НомерЗагруженнойВерсии();
//	КонецЕсли;
//
//@skip-warning
Процедура ПриОпределенииНачальногоНомераВерсииКлассификатора(Идентификатор, НачальныйНомерВерсии) Экспорт
	
	Если ПодсистемаСуществует("ЗЕРНО") Тогда
		МодульИнтеграцияЗЕРНО = ОбщийМодуль("ЗЕРНО");
		МодульИнтеграцияЗЕРНО.ПриОпределенииНачальногоНомераВерсииКлассификатора(Идентификатор, НачальныйНомерВерсии);
	КонецЕсли;
	
	Если ПодсистемаСуществует("ВетИС") Тогда
		МодульИнтеграцияВЕТИС = ОбщийМодуль("ВЕТИС");
		МодульИнтеграцияВЕТИС.ПриОпределенииНачальногоНомераВерсииКлассификатора(Идентификатор, НачальныйНомерВерсии);
	КонецЕсли;
	
КонецПроцедуры

// Переопределяются алгоритмы обработки файла загруженного
// из сервиса классификаторов. После обработки файла нельзя удалять
// временного хранилища, т.к. при необходимости он будет сохранен в
// кэше для последующего использования.
//
// Параметры:
//  Идентификатор           - Строка - идентификатор классификатора в сервисе классификаторов.
//                            Определяется в процедуре ПриДобавленииКлассификаторов.
//  Версия                  - Число - номер загруженной версии;
//  Адрес                   - Строка - адрес двоичных данных файла обновления во
//                            временном хранилище;
//  Обработан               - Булево - если Ложь, при обработке файла обновления были ошибки
//                            и его необходимо загрузить повторно;
//  ДополнительныеПараметры - Структура - содержит дополнительные параметры обработки.
//                            Необходимо использовать для передачи значений в переопределяемый
//                            метод РаботаСКлассификаторамиВМоделиСервисаПереопределяемый.ПриОбработкеОбластиДанных
//                            и метод ИнтеграцияПодсистемБИП.ПриОбработкеОбластиДанных..
// Пример:
//	Если Идентификатор = "CentralBankRefinancingRate" Тогда
//		Обработан = РегистрыСведений.СтавкиРефинансирования.ОбновитьДанныеРегистраИзФайла(Адрес, ДополнительныеПараметры);
//	КонецЕсли;
//
//@skip-warning
Процедура ПриЗагрузкеКлассификатора(Идентификатор, Версия, Адрес, Обработан, ДополнительныеПараметры) Экспорт
	
	Если ПодсистемаСуществует("ЗЕРНО") Тогда
		МодульИнтеграцияЗЕРНО = ОбщийМодуль("ЗЕРНО");
		МодульИнтеграцияЗЕРНО.ПриЗагрузкеКлассификатора(Идентификатор, Версия, Адрес, Обработан, ДополнительныеПараметры);
	КонецЕсли;
	
	Если ПодсистемаСуществует("ВетИС") Тогда
		МодульИнтеграцияВЕТИС = ОбщийМодуль("ВЕТИС");
		МодульИнтеграцияВЕТИС.ПриЗагрузкеКлассификатора(Идентификатор, Версия, Адрес, Обработан, ДополнительныеПараметры);
	КонецЕсли;
	
КонецПроцедуры

// см. РаботаСКлассификаторамиВМоделиСервисаПереопределяемый.ПриОпределенииИдентификаторовКлассификаторов
Процедура ПриОпределенииИдентификаторовКлассификаторовВМоделиСервиса(Идентификаторы) Экспорт
	
	Если ПодсистемаСуществует("ЗЕРНО") Тогда
		МодульИнтеграцияЗЕРНО = ОбщийМодуль("ЗЕРНО");
		МодульИнтеграцияЗЕРНО.ПриОпределенииИдентификаторовКлассификаторовВМоделиСервиса(Идентификаторы);
	КонецЕсли;
	
	Если ПодсистемаСуществует("ВетИС") Тогда
		МодульИнтеграцияВЕТИС = ОбщийМодуль("ВЕТИС");
		МодульИнтеграцияВЕТИС.ПриОпределенииИдентификаторовКлассификаторовВМоделиСервиса(Идентификаторы);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

// Обработчик заполнения вида продукции в шапке документа ГосИС. Вызывается после заполнения табличной части "Товары",
//   берет вид продукции из первой строки.
//
// Параметры:
//   ДокументОбъект - ДокументОбъект - документ ГосИС с реквизитом "ВидПродукции" в шапке
//
Процедура ЗаполнитьВидПродукцииПоТабличнойЧасти(ДокументОбъект) Экспорт
	
	Если ДокументОбъект.Товары.Количество() Тогда
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	&Номенклатура КАК Номенклатура
		|ПОМЕСТИТЬ ДанныеШтрихкодовУпаковок
		|;
		|
		|/////////////////////////////////////////////
		|"
		+
		ШтрихкодированиеИС.ТекстЗапросаСвойстваМаркируемойПродукции()
		+
		"
		|;
		|/////////////////////////////////////////////
		|
		|ВЫБРАТЬ
		|	ДанныеПоВидуПродукции.ВидПродукции         КАК ВидПродукции
		|ИЗ
		|	СвойстваМаркируемойПродукции КАК ДанныеПоВидуПродукции
		|";

		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Номенклатура", ДокументОбъект.Товары[0].Номенклатура);
		Выборка = Запрос.Выполнить().Выбрать();
		
		Если Выборка.Следующий() Тогда
			Если Выборка.Количество() = 1 Тогда
				ДокументОбъект.ВидПродукции = Выборка.ВидПродукции;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает структуру параметров заполнения табличной части.
// 
// Параметры:
//  ВходноеЗначение - Массив Из ПеречислениеСсылка.ВидыПродукцииИС, ПеречислениеСсылка.ВидыПродукцииИС - виды продукции, которые поддерживает документ.
// Возвращаемое значение:
//  Структура - 
Функция ПараметрыЗаполненияТабличнойЧастиТовары(ВходноеЗначение) Экспорт
	
	Если ТипЗнч(ВходноеЗначение) = Тип("ПеречислениеСсылка.ВидыПродукцииИС") Тогда
		ВидыПродукции = Новый Массив();
		ВидыПродукции.Добавить(ВходноеЗначение);
	Иначе
		ВидыПродукции = ВходноеЗначение;
	КонецЕсли;
	
	ПараметрыЗаполнения = БазовыеПараметрыОбработкиТабличнойЧастиТовары(ВидыПродукции);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		
		Если ВидыПродукции.Найти(Перечисления.ВидыПродукцииИС.Алкогольная) <> Неопределено Тогда
			МодульШтрихкодированиеЕГАИС = ОбщегоНазначения.ОбщийМодуль("ШтрихкодированиеЕГАИС");
			МодульШтрихкодированиеЕГАИС.ДополнитьПараметрыЗаполненияТабличнойЧастиТовары(ПараметрыЗаполнения);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		
		Если ШтрихкодированиеИС.ПрисутствуетПродукцияИСМП(ВидыПродукции)
			Или ШтрихкодированиеИС.ПрисутствуетТабачнаяПродукция(ВидыПродукции) Тогда
			
			МодульШтрихкодированиеИСМПКлиентСервер = ОбщегоНазначения.ОбщийМодуль("ШтрихкодированиеИСМПКлиентСервер");
			МодульШтрихкодированиеИСМПКлиентСервер.ДополнитьПараметрыЗаполненияТабличнойЧастиТовары(ПараметрыЗаполнения);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ПараметрыЗаполнения;
	
КонецФункции

//Возвращает поля поиска строки табличной части по номенклутаре, характеристикике, опционально серии.
//
//Параметры:
//   ЕстьСерии - Булево - наличие колонки "Серия" в табличной части.
//   ЕстьGTIN - Булево - наличие колонки "GTIN" в табличной части.
//   СпецификаМаркировкаМолочнойПродукции - Булево - специфика в табличной части маркировки
//      (молочная продукция с/без ВетИС - срок годности с/без идентификатора ВетИС, соответственно).
//
//Возвращаемое значение:
//   Структура - поля поиска:
// * Номенклатура - ОпределяемыйТип.Номенклатура - Пустоне значение номенклатуры.
// * Характеристика  - ОпределяемыйТип.ХарактеристикаНоменклатуры - Пустое значение характеристики.
// * Серия - ОпределяемыйТип.СерияНоменклатуры - Пустое значение серии. Может отсутствовать.
// * GTIN  - ОпределяемыйТип.GTIN - Пустое значение GTIN. Может отсутствовать.
// * ИдентификаторПроисхожденияВЕТИС - ОпределяемыйТип.ИдентификаторПроисхожденияВЕТИС - пустое значение идентификатора. Может отсутствовать.
// * СрокГодности - Дата - пустое значение срока годности. Может отсутствовать.
Функция ПоляПоискаМаркируемойПродукции(ЕстьСерии = Истина, ЕстьGTIN = Ложь, СпецификаМаркировкаМолочнойПродукции = Ложь) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Номенклатура",   ПустоеЗначениеОпределяемогоТипа("Номенклатура"));
	Результат.Вставить("Характеристика", ПустоеЗначениеОпределяемогоТипа("ХарактеристикаНоменклатуры"));
	
	Если ЕстьСерии Тогда
		Результат.Вставить("Серия", ПустоеЗначениеОпределяемогоТипа("СерияНоменклатуры"));
	КонецЕсли;
	
	Если ЕстьGTIN Тогда
		Результат.Вставить("GTIN", ПустоеЗначениеОпределяемогоТипа("GTIN"));
	КонецЕсли;
	
	Если СпецификаМаркировкаМолочнойПродукции Тогда
		Результат.Вставить("ИдентификаторПроисхожденияВЕТИС", ПустоеЗначениеОпределяемогоТипа("ИдентификаторПроисхожденияВЕТИС"));
		Результат.Вставить("СрокГодности", '00010101');
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Рег задания настроены.
// 
// Параметры:
//  РезультатЗапроса - РезультатЗапроса - Результат запроса
//  ИдентификаторПроблемы - Строка - Идентификатор проблемы
//  ВсеЗадания - Булево - Все задания
// 
// Возвращаемое значение:
//  Булево - Рег задания настроены
Функция РегЗаданияНастроены(РезультатЗапроса, ИдентификаторПроблемы, ВсеЗадания = Истина) Экспорт
	
	РезультатПроверки = Неопределено;
	
	Выборка = РезультатЗапроса[ИдентификаторПроблемы].Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если Не ЗначениеЗаполнено(Выборка.РегламентноеЗадание) Тогда 
			Если ВсеЗадания И РезультатПроверки = Истина Тогда
				РезультатПроверки = Ложь;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		УстановитьПривилегированныйРежим(Истина);
		Задание = РегламентныеЗаданияСервер.Задание(Выборка.РегламентноеЗадание);
		УстановитьПривилегированныйРежим(Ложь);
		ТекВключено = Задание <> Неопределено И Задание.Использование = Истина;
		
		РезультатПроверки = (ТекВключено Или РезультатПроверки = Истина И Не ВсеЗадания)
			Или (ТекВключено И ВсеЗадания И РезультатПроверки = Истина);
	КонецЦикла;
	
	Возврат РезультатПроверки = Истина;
	
КонецФункции

#Область МаркируемаяПродукция

// Определяет ведение учета маркируемой продукции.
//
// Возвращаемое значение:
//  Булево - учет маркируемой продукции ведется
Функция ИспользуетсяМаркируемаяПродукция() Экспорт
	
	Результат = Ложь;
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЕГАИС");
		Результат = Результат Или Модуль.ИспользуетсяМаркируемаяПродукция();
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияИСМП");
		Результат = Результат Или Модуль.ИспользуетсяМаркируемаяПродукция();
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Возвращает свойства маркируемой продукции по номенклатуре и характеристике.
// 
// Параметры:
// 	Номенклатура - ОпределяемыйТип.Номенклатура - Номенклатура.
// 	Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - Характеристика.
// Возвращаемое значение:
// 	Структура - Описание:
//	 * Номенклатура - ОпределяемыйТип.Номенклатура - Номенклатура.
//	 * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - Характеристика.
//	 * МаркируемаяПродукция - Булево - Истина, если продукция маркируемая.
//	 * ВидПродукции - ПеречислениеСсылка.ВидыПродукцииИС - Вид маркируемой продукции.
Функция СвойстваМаркируемойПродукции(Номенклатура, Характеристика) Экспорт
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&Номенклатура   КАК Номенклатура,
	|	&Характеристика КАК Характеристика
	|ПОМЕСТИТЬ ДанныеШтрихкодовУпаковок
	|;
	|
	|/////////////////////////////////////////////
	|"
	+
	ШтрихкодированиеИС.ТекстЗапросаСвойстваМаркируемойПродукции()
	+
	"
	|;
	|/////////////////////////////////////////////
	|
	|ВЫБРАТЬ
	|	&Номенклатура                              КАК Номенклатура,
	|	&Характеристика                            КАК Характеристика,
	|	ДанныеПоВидуПродукции.МаркируемаяПродукция КАК МаркируемаяПродукция,
	|	ДанныеПоВидуПродукции.ВидПродукции         КАК ВидПродукции
	|ИЗ
	|	СвойстваМаркируемойПродукции КАК ДанныеПоВидуПродукции
	|";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Номенклатура",   Номенклатура);
	Запрос.УстановитьПараметр("Характеристика", Характеристика);
	ДанныеТаблица = Запрос.Выполнить().Выгрузить();
	
	Если ДанныеТаблица.Количество() = 0 Тогда
		ДанныеТаблица.Добавить();
	КонецЕсли;
	СвойстваМаркируемойПродукции = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(ДанныеТаблица[0]);
	
	Возврат СвойстваМаркируемойПродукции;
	
КонецФункции

//Получает вид продукции по номенклатуре
//
//Параметры:
//   Номенклатура - ОпределяемыйТип.Номенклатура - Номенклатура.
//
//Возвращаемое значение:
//   ПеречислениеСсылка.ВидыПродукцииИС - вид продукции по номенклатуре
//
Функция ВидПродукцииПоНоменклатуре(Номенклатура) Экспорт
	
	Возврат СвойстваМаркируемойПродукции(Номенклатура, Неопределено).ВидПродукции;
	
КонецФункции

// Настройка конфигурации для ведения учета в произвольных единицах измерения:
//  * Ложь (по умолчанию) - индивидуальная потребительская упаковка безусловно соответствует учетному количеству = 1.
//  * Истина - индивидуальная потребительская упаковка может соответствовать произвольному (в т.ч. нефиксированному)
//    учетному количеству. Запрашивается коэффициент GTIN для потребительской упаковки при его первом считывании.
//    Примеры использования: базовая единица измерения  - мерная (литр, килограмм); сигара; блок сигарет.
// Параметры:
//  ВидПродукции - Перечислениессылка.ВидыПродукцииИС - Вид продукции.
// 
// Возвращаемое значение:
//  Булево - Единица учета может не совпадать с индивидуальной потребительской упаковкой по виду продукции
Функция ЕдиницаУчетаМожетНеСовпадатьСИндивидуальнойПотребительскойУпаковкойПоВидуПродукции(ВидПродукции) Экспорт
	
	РазмерностиМогутРазличаться = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеПроизвольныхЕдиницУчета(РазмерностиМогутРазличаться, ВидПродукции);
	Возврат РазмерностиМогутРазличаться;
	
КонецФункции

#Область ОписаниеНоменклатурыИС

// Работа с регистром "ОписаниеНоменклатурыИС" при использовании источника описания номенклатуры отличного от ссылки 
//   на номенклатуру:
//   * Дополняет входящий массив классами номенклатуры,
//   * Возвращает соответствие добавленных классов и исходной номенклатуры.
//
// Параметры:
//  Номенклатура - Массив Из ОпределяемыйТип.ИсточникОписанияноменклатурыИС - Источник описания номенклатуры.
// Возвращаемое значение:
//  Соответствие - описание добавленных классов номенклатуры:
//   * Ключ - ОпределяемыйТип.ИсточникОписанияноменклатурыИС - Источник описания номенклатуры,
//   * Значение - Массив Из ОпределяемыйТип.номенклатура - номенклатура из входящего массива
Функция ДополнитьИсточникиОписанияНоменклатуры(Номенклатура) Экспорт
	
	СоответстиеИсточникаНоменклатуре = Новый Соответствие;
	ИнтеграцияИСПереопределяемый.ДополнитьИсточникиОписанияНоменклатуры(Номенклатура, СоответстиеИсточникаНоменклатуре);
	Для Каждого КлючИЗначение Из СоответстиеИсточникаНоменклатуре Цикл
		Номенклатура.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	Возврат СоответстиеИсточникаНоменклатуре;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Прочее

// Возвращает пароль к сертификату, если доступен текущему пользователю.
// При вызове в привилегированном режиме текущий пользователь не учитывается.
//
// Параметры:
//  Сертификат - Неопределено - вернуть пароли ко всем сертификатам, доступным текущему пользователю.
//             - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - вернуть пароль
//                 к указанному сертификату.
//              
// Возвращаемое значение:
//  Неопределено - пароль для указанного сертификата не указан.
//  Строка       - пароль для указанного сертификата.
//  Соответствие - все заданные пароли, доступные текущему пользователю
//                 в виде ключ - сертификат и значение - пароль.
//
Функция ПарольКСертификату(Сертификат = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Данные = Константы.КонтекстРаботыИС.Получить().Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	РольДляПроверки = Неопределено;
	Если Метаданные.Роли.Найти("ДобавлениеИзменениеЭлектронныхПодписейИШифрование") <> Неопределено Тогда
		РольДляПроверки = "ДобавлениеИзменениеЭлектронныхПодписейИШифрование";
	ИначеЕсли Метаданные.Роли.Найти("ДобавлениеИзменениеСертификатовКлючейЭлектроннойПодписиИШифрования") <> Неопределено Тогда
		РольДляПроверки = "ДобавлениеИзменениеСертификатовКлючейЭлектроннойПодписиИШифрования";
	Иначе
		ВызватьИсключение НСтр("ru = 'Не определена роль для добавления и (или) изменения электронных подписей'");
	КонецЕсли;
	
	Если Не Пользователи.РолиДоступны(РольДляПроверки) Тогда
		Если Сертификат <> Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Если Сертификат <> Неопределено Тогда
		Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Свойства = Данные.Получить(Сертификат);
		
		Если ТипЗнч(Свойства) = Тип("Структура")
		   И Свойства.Свойство("Пароль")
		   И ТипЗнч(Свойства.Пароль) = Тип("Строка")
		   И Свойства.Свойство("Пользователь")
		   И ТипЗнч(Свойства.Пользователь) = Тип("СправочникСсылка.Пользователи") Тогда
			
		   Если Свойства.Пользователь = Пользователи.ТекущийПользователь()
			   ИЛИ Свойства.Пользователь = Справочники.Пользователи.ПустаяСсылка() Тогда
				
				Возврат Свойства.Пароль;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
	ПаролиСертификатов = Новый Соответствие;
	
	Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
		Возврат ПаролиСертификатов;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Данные Цикл
		Свойства = КлючИЗначение.Значение;
		
		Если ТипЗнч(Свойства) = Тип("Структура")
		   И Свойства.Свойство("Пароль")
		   И ТипЗнч(Свойства.Пароль) = Тип("Строка")
		   И Свойства.Свойство("Пользователь")
		   И ТипЗнч(Свойства.Пользователь) = Тип("СправочникСсылка.Пользователи") Тогда
			
		   Если Свойства.Пользователь = Пользователи.ТекущийПользователь()
			   ИЛИ Свойства.Пользователь = Справочники.Пользователи.ПустаяСсылка()
			 Или ПривилегированныйРежим() Тогда
				ПаролиСертификатов.Вставить(КлючИЗначение.Ключ, Свойства.Пароль);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПаролиСертификатов;
	
КонецФункции

// Серверное ожидание перед очередным действием в соответствии с ограничениями сервиса
//
// Параметры:
//   ВремяОжидания   - Число     - длительность паузы
//   ПараметрыОбмена - Структура - параметры обмена с обязательным свойством:
//    * ФоновоеЗадание - Неопределено, ФоновоеЗадание - задание ожидания
//
Процедура Ожидать(ВремяОжидания, ПараметрыОбмена) Экспорт
	
	Если ВремяОжидания <= 0 Тогда
		Возврат;
	КонецЕсли;
	
	ФоновоеЗадание = Неопределено;
	Если ПараметрыОбмена.ФоновоеЗадание = Неопределено Тогда
		
		ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
		ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
		
		Если ФоновоеЗадание = Неопределено Тогда
			Если ОбщегоНазначения.РазделениеВключено()
				И ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.БазоваяФункциональность") Тогда
				ОбщийМодульОбщегоНазначенияБТС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБТС");
				ОбщийМодульОбщегоНазначенияБТС.Пауза(ВремяОжидания);
				Возврат;
			КонецЕсли;
		Иначе
			ПараметрыОбмена.ФоновоеЗадание = ФоновоеЗадание;
		КонецЕсли;
		
	Иначе
		ФоновоеЗадание = ПараметрыОбмена.ФоновоеЗадание;
	КонецЕсли;
	
	Если ФоновоеЗадание <> Неопределено Тогда
		Попытка
			ФоновоеЗадание.ОжидатьЗавершения(ВремяОжидания);
		Исключение
			ВремяОжидания = 0;
		КонецПопытки;
	КонецЕсли;
	
	Если ВремяОжидания = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		
		НастройкиПрокси = Новый ИнтернетПрокси(Ложь);
		НастройкиПрокси.НеИспользоватьПроксиДляЛокальныхАдресов = Истина;
		НастройкиПрокси.НеИспользоватьПроксиДляАдресов.Добавить("127.0.0.0");
		
		Попытка
			Loopback = Новый HTTPСоединение(
				"127.0.0.0",,,,НастройкиПрокси,
				ВремяОжидания);
			Loopback.Получить(Новый HTTPЗапрос());
		Исключение
			ВремяОжидания = 0;
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

// Серверное ожидание перед очередным действием в соответствии с ограничениями сервиса
//
// Параметры:
//  ВремяОжидания - Число, Неопределено - время ожидания
// Возвращаемое значение:
//  Число, Неопределено - время ожидания
Функция ВремяОжидания(ВремяОжидания) Экспорт
	
	Если ТипЗнч(ВремяОжидания) = Тип("Число") Тогда
		
		Возврат ?(ВремяОжидания <= 0, Неопределено, ВремяОжидания);
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

Функция ХэшСуммаСтроки(СтрокаДляРасчетаХеша) Экспорт
	
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(СтрокаДляРасчетаХеша);
	
	Возврат Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область РаботаСXDTO

// Функция - Данные для расшифровки ошибок
//
// Параметры:
//  ИмяМакета - Строка - макет в котором искать описание ошибки
//  Глубина   - Число  - уровень вложенности ошибки в макете
// 
// Возвращаемое значение:
//  Структура - из переданных параметров
//
Функция ДанныеДляРасшифровкиОшибок(ИмяМакета = Неопределено, Глубина = Неопределено) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяМакета", ИмяМакета);
	Результат.Вставить("Глубина",   Глубина);
	Результат.Вставить("Таблица",   Неопределено);
	Возврат Результат;
	
КонецФункции

// Функция возвращает пустую таблицу значений пользовательских представлений полей
// 
// Возвращаемое значение:
//  ТаблицаЗначений - пустая таблица (отсутствия пользовательской расшифровки полей)
//
Функция ПустаяТаблицаПредставленийПолей() Экспорт
	
	ТаблицаПредставлений = Новый ТаблицаЗначений;
	ТаблицаПредставлений.Колонки.Добавить("ПространствоИмен", Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("ЛокальноеИмя",     Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("Представление",    Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("Обязательное",     Новый ОписаниеТипов("Булево"));
	ТаблицаПредставлений.Колонки.Добавить("Глубина",          Новый ОписаниеТипов("Число"));
	Возврат ТаблицаПредставлений;
	
КонецФункции

#КонецОбласти

#Область РаботаСЧасовымиПоясами

Функция ДатаИзСтрокиISO(Значение) Экспорт
	
	Конвертор = ИнтеграцияИС.ОбъектXDTOПоИмениСвойства("http://gosis.1c.ru/Convertor", "query");
	Конвертор.ХранилищеДаты = ИнтеграцияИС.ОбъектXDTOПоИмениТипа(Конвертор, "ХранилищеДаты");
	
	Попытка
		Конвертор.ХранилищеДаты.Значение = Значение;
		Возврат Конвертор.ХранилищеДаты.Значение;
	Исключение
		Возврат Дата(1, 1, 1);
	КонецПопытки;
	
КонецФункции

Функция ДатаИзСтрокиUNIX(Знач Значение, Делитель = 1000, ПриводитьКМестномуВремени = Истина) Экспорт
	
	Возврат ИнтеграцияИСКлиентСервер.ДатаИзСтрокиUNIX(Значение, Делитель, ПриводитьКМестномуВремени);
	
КонецФункции

Функция ДатаИзСтроки(Значение, Делитель = 1000, ПриводитьКМестномуВремени = Истина) Экспорт
	
	Если СтрНайти(Значение, "T") > 0 Тогда
		Возврат ДатаИзСтрокиISO(Значение);
	Иначе
		Возврат ДатаИзСтрокиUNIX(Значение, Делитель, ПриводитьКМестномуВремени);
	КонецЕсли;
	
КонецФункции

Функция ДатаВСтрокуUNIX(Дата, Делитель = 1000) Экспорт
	
	Значение = (УниверсальноеВремя(Дата) - '19700101') * Делитель;
	
	Возврат Значение;
	
КонецФункции

// Формирует представление даты с часовым поясом.
//
// Параметры:
//  Дата        - Дата - дата/время, для которой нужно вывести представление.
//  ЧасовойПояс - Строка - идентификатор часового пояса.
// 
// Возвращаемое значение:
//  Строка - представление даты с часовым поясом.
//
Функция ДатаСЧасовымПоясом(Дата, Знач ЧасовойПояс = Неопределено, ЧасовойПоясСМинутами = Истина, Разделитель = Неопределено) Экспорт
	
	Если ЧасовойПояс = Неопределено Тогда
		ЧасовойПояс = ЧасовойПоясСеанса();
	КонецЕсли;
	
	Смещение = (Дата - УниверсальноеВремя(Дата, ЧасовойПояс)) / 3600;
	Если Смещение > 0 Тогда
		Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "+" + Формат(+Смещение, "ЧЦ=2; ЧН=; ЧВН=") + ?(ЧасовойПоясСМинутами, ":00", "");
	Иначе
		Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "-" + Формат(-Смещение, "ЧЦ=2; ЧН=; ЧВН=") + ?(ЧасовойПоясСМинутами, ":00", "");
	КонецЕсли;
	
	Если Разделитель <> Неопределено Тогда
		Результат = СтрЗаменить(Результат, "T", Разделитель);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует представление даты с часовым поясом.
//
// Параметры:
//  Дата        - ДатаВремя - дата, для которой нужно вывести представление.
//  ЧасовойПояс - Строка - идентификатор часового пояса.
// 
// Возвращаемое значение:
//  Строка - представление даты с часовым поясом.
//
Функция ДатаСЧасовымПоясомЦРПТ(Дата, Знач ЧасовойПояс = Неопределено) Экспорт
	
	Если ЧасовойПояс = Неопределено Тогда
		ЧасовойПояс = ЧасовойПоясСеанса();
	КонецЕсли;
	
	Смещение = (Дата - УниверсальноеВремя(Дата, ЧасовойПояс)) / 3600;
	Если Смещение > 0 Тогда
		Результат = Формат(Дата, "ДФ=dd.MM.yyyyTЧЧ:мм:сс") + "+" + Формат(+Смещение, "ЧЦ=2; ЧН=; ЧВН=");
	Иначе
		Результат = Формат(Дата, "ДФ=dd.MM.yyyyTЧЧ:мм:сс") + "-" + Формат(-Смещение, "ЧЦ=2; ЧН=; ЧВН=");
	КонецЕсли;
	
	Результат = СтрЗаменить(Результат, "T", " ");
	
	Возврат Результат;
	
КонецФункции

// Формирует представление даты в формате Coordinated Universal Time
//
// Параметры:
//  Дата - Дата - дата/время, представление которой необходимо получить.
//  ЧасовойПояс - Строка - идентификатор часового пояса.
//
// Возвращаемое значение:
//  Строка - представление даты в формате Coordinated Universal Time(UTC).
//
Функция ДатаUTC(Знач Дата, ЧасовойПояс = Неопределено) Экспорт
	
	Если ЧасовойПояс <> Неопределено Тогда
		Дата = УниверсальноеВремя(Дата, ЧасовойПояс);
	КонецЕсли;
	
	Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + ".000Z";
	
	Возврат Результат;
	
КонецФункции

Функция ДатаСАТУРН(Знач Дата, ЧасовойПояс = Неопределено) Экспорт
	
	Если ЧасовойПояс <> Неопределено Тогда
		Дата = УниверсальноеВремя(Дата, ЧасовойПояс);
	КонецЕсли;
	
	Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм");
	
	Возврат Результат;
	
КонецФункции

Функция ДатаСАТУРН_ISO8601(Знач Дата) Экспорт
	
	Попытка
		Результат = XMLЗначение(Тип("Дата"), Дата);
	Исключение
		Возврат Дата(1, 1, 1);
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Возвращает временную дату, которая будет в дальнейшем преобразована в дату с часовым поясом.
//
// Параметры:
//  Дата - Дата - Дата для преобразования.
// 
// Возвращаемое значение:
//  Дата - Временная дата
//
Функция ВременнаяДата(Дата) Экспорт
	
	Возврат ДобавитьМесяц(Дата, -12 * 1000);
	
КонецФункции

// Устанавливает в ОбъектXDTO вместо даты со смещением временную дату. В дальнейшем временная дата будет заменена датой
// со смещением в результирующем ХМL. Тем самым обходится ограничение ОбъектXDTO, который не позволяет устанавливать в
// свойство дату со смещением.
//
// Параметры:
//  ОбъектXDTO            - ОбъектXDTO - в свойство данного объекта помещается дата.
//  ИмяСвойства           - Строка     - имя свойства, в которое устанавливается дата.
//  Дата                  - Дата       - дата/время, которая устанавливается в свойство.
//  ХранилищеВременныхДат - Соответствие - в нем хранится соответствие временных дат и дат со смещением.
//
Процедура УстановитьДатуСЧасовымПоясом(ОбъектXDTO, ИмяСвойства, Дата, ХранилищеВременныхДат) Экспорт
	
	ДатаСЧасовымПоясом = ДатаСЧасовымПоясом(Дата);
	
	ВременнаяДатаUTC = ДатаUTC(ВременнаяДата(Дата));
	
	ОбъектXDTO[ИмяСвойства] = ВременнаяДатаUTC;
	ЛексическоеЗначениеВременнойДаты = ОбъектXDTO.ПолучитьXDTO(ИмяСвойства).ЛексическоеЗначение;
	
	ХранилищеВременныхДат.Вставить(ЛексическоеЗначениеВременнойДаты, ДатаСЧасовымПоясом);
	
КонецПроцедуры

// Заменяет временные даты в тексте сообщения в формате XML на даты со смещением, согласно соответствию.
//
// Параметры:
//  ХранилищеВременныхДат - Соответствие - хранит временные даты, которые нужно заменить на даты со смещением
//  ТекстСообщенияXML     - Строка - текст сообщения, в котором выполняется замена.
// 
// Возвращаемое значение:
//  Строка - ТекстСообщенияXML, в котором выполнена замена.
//
Функция ПреобразоватьВременныеДаты(ХранилищеВременныхДат, Знач ТекстСообщенияXML) Экспорт
	
	Текст = ТекстСообщенияXML;
	
	Для Каждого КлючИЗначение Из ХранилищеВременныхДат Цикл
		
		ВременнаяДата = КлючИЗначение.Ключ;
		Дата = КлючИЗначение.Значение;
		
		Текст = СтрЗаменить(Текст, ВременнаяДата, Дата);
		
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПечати

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

#КонецОбласти

#Область ОбщиеПредставления

// Заполняет представление регламентного задания (реквизиты ЗаданиеАктивно, ТекстРасписания)
//
// Параметры:
//  Задание				 - РегламентноеЗадание, Неопределено - регламентное задание представление которого необходимо получить
//  ТекстРасписания		 - Строка - представление расписания (выходной)
//  РасписаниеАктивно	 - Булево - использование задания (выходной)
//
Процедура ПолучитьТекстЗаголовкаИРасписанияРегламентнойНастройки(Задание, ТекстРасписания, РасписаниеАктивно) Экспорт
	
	РасписаниеАктивно = Ложь;
	
	Если Задание = Неопределено Тогда
		
		ТекстРасписания = НСтр("ru = '<Расписание не задано>'");
		
	Иначе
		
		Если Задание.Использование Тогда
			РасписаниеАктивно = Истина;
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание: %1'"), Строка(Задание.Расписание));
		Иначе
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание (НЕ АКТИВНО): %1'"), Строка(Задание.Расписание));
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Иницициализирует таблицу для расчета содержимого упаковки
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица для расчета содержимого упаковки:
//   * Номенклатура   - ОпределяемыйТип.Номенклатура, Строка               - номенклатура
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры, Строка - характеристика,
//   * Серия          - ОпределяемыйТип.СерияНоменклатуры, Строка          - серия,
//   * Количество     - Число                                              - Количество.
Функция ИнициализироватьСодержимоеУпаковки() Экспорт
	
	ТипСтрока = ОбщегоНазначения.ОписаниеТипаСтрока(200);
	
	СодержимоеУпаковки = Новый ТаблицаЗначений;
	СодержимоеУпаковки.Колонки.Добавить("Номенклатура",   Новый ОписаниеТипов(ТипСтрока, ОпределяемыеТипы().Номенклатура.Тип.Типы()));
	СодержимоеУпаковки.Колонки.Добавить("Характеристика", Новый ОписаниеТипов(ТипСтрока, ОпределяемыеТипы().ХарактеристикаНоменклатуры.Тип.Типы()));
	СодержимоеУпаковки.Колонки.Добавить("Серия",          Новый ОписаниеТипов(ТипСтрока, ОпределяемыеТипы().СерияНоменклатуры.Тип.Типы()));
	СодержимоеУпаковки.Колонки.Добавить("Количество",     Новый ОписаниеТипов("Число"));
	
	Возврат СодержимоеУпаковки;
	
КонецФункции

// Возвращает строку, состоящую из различных частей наименований номенклатуры, входящей в состав упаковки
//
// Параметры:
//  Таблица - См. ИнициализироватьСодержимоеУпаковки.
//
// Возвращаемое значение:
//  Строка - строка, состоящая из различных наименований переданной номенклатуры.
Функция ПредставлениеСоставаУпаковки(Таблица) Экспорт
	
	Таблица.Сортировать("Количество УБЫВ, Номенклатура ВОЗР, Характеристика ВОЗР, Серия ВОЗР");
	
	ДеревоЧастейНаименований = Новый ДеревоЗначений();
	
	Для Каждого ЭлементДанных Из Таблица Цикл
		
		ПредставлениеНоменклатуры = ИнтеграцияИС.ПредставлениеНоменклатуры(
			ЭлементДанных.Номенклатура, ЭлементДанных.Характеристика);
		
		ЧастиНаименования = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(ПредставлениеНоменклатуры);
		
		НомерТекущейЧасти  = 1;
		СтрокиТекущейЧасти = ДеревоЧастейНаименований.Строки;
		
		Для Каждого ЧастьНаименования Из ЧастиНаименования Цикл
			
			ИмяТекущейКолонки = "ЧастьНаименования" + НомерТекущейЧасти;
			
			Если ДеревоЧастейНаименований.Колонки.Найти(ИмяТекущейКолонки) = Неопределено Тогда
				ДеревоЧастейНаименований.Колонки.Добавить(ИмяТекущейКолонки, ОбщегоНазначения.ОписаниеТипаСтрока(100));
			КонецЕсли;
			
			СтрокаЧастиНаименования = СтрокиТекущейЧасти.Найти(СокрЛП(ЧастьНаименования), ИмяТекущейКолонки, Ложь);
			
			Если СтрокаЧастиНаименования = Неопределено Тогда
				СтрокаЧастиНаименования = СтрокиТекущейЧасти.Добавить();
				СтрокаЧастиНаименования[ИмяТекущейКолонки] = СокрЛП(ЧастьНаименования);
			КонецЕсли;
			
			НомерТекущейЧасти  = НомерТекущейЧасти + 1;
			СтрокиТекущейЧасти = СтрокаЧастиНаименования.Строки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	СтрокаСоставаУпаковки = "";
	ОграничительСостава   = 7;
	
	Если ДеревоЧастейНаименований.Строки.Количество() > 0 Тогда
		СоставитьСтрокуСоставаУпаковки(СтрокаСоставаУпаковки, ДеревоЧастейНаименований.Строки, ОграничительСостава);
	КонецЕсли;
	
	Если Прав(СтрокаСоставаУпаковки, 1) = "," Тогда
		СтрокаСоставаУпаковки = Сред(СтрокаСоставаУпаковки, 1, СтрДлина(СтрокаСоставаУпаковки) - 1);
	КонецЕсли;
	
	Возврат СтрокаСоставаУпаковки;
	
КонецФункции

#КонецОбласти

#Область БСП

// (См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииКомандПодключенныхКОбъекту)
//
Процедура ПриОпределенииКомандПодключенныхКОбъекту(НастройкиФормы, Источники, ПодключенныеОтчетыИОбработки, Команды) Экспорт
	
	Если НастройкиФормы.ИмяФормы = "Обработка.ГенерацияШтрихкодовУпаковок.Форма.Форма" Тогда
		Обработки.ГенерацияШтрихкодовУпаковок.ПриОпределенииКомандПодключенныхКОбъекту(Команды);
	ИначеЕсли СтрНачинаетсяС(НастройкиФормы.ИмяФормы, "Справочник.ШтрихкодыУпаковокТоваров.Форма") Тогда
		Справочники.ШтрихкодыУпаковокТоваров.ПриОпределенииКомандПодключенныхКОбъекту(Команды);
	КонецЕсли;
	
КонецПроцедуры

// (См. ЗапретРедактированияРеквизитовОбъектовПереопределяемый.ПриОпределенииКомандПодключенныхКОбъекту)
//
Процедура ПриОпределенииОбъектовСЗаблокированнымиРеквизитами(Объекты) Экспорт
	
	Объекты.Вставить(
		Метаданные.Справочники.ШтрихкодыУпаковокТоваров.ПолноеИмя(),
		"ПолучитьБлокируемыеРеквизитыОбъекта");
	
КонецПроцедуры

Процедура ПодключитьВерсионирование(Форма) Экспорт
	
	// СтандартныеПодсистемы.ВерсионированиеОбъектов
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВерсионированиеОбъектов") Тогда
		МодульВерсионированиеОбъектов = ОбщегоНазначения.ОбщийМодуль("ВерсионированиеОбъектов");
		МодульВерсионированиеОбъектов.ПриСозданииНаСервере(Форма);
	КонецЕсли;
	// Конец СтандартныеПодсистемы.ВерсионированиеОбъектов
	
КонецПроцедуры

// Возвращает признак того, что файлы должны храниться в томах на диске.
//
// Возвращаемое значение:
//  Булево - Истина, если указано хранить файлы в томах на диске, иначе - Ложь.
//
Функция ХранитьФайлыВТомахНаДиске() Экспорт
	
	Возврат Истина;
	
КонецФункции

// См. УправлениеПечатьюПереопределяемый.ПриОпределенииОбъектовСКомандамиПечати.
Процедура ПриОпределенииОбъектовСКомандамиПечати(СписокОбъектов) Экспорт
	
	СписокОбъектов.Добавить(Справочники.ШтрихкодыУпаковокТоваров);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ВетИС") Тогда
		СписокОбъектов.Добавить(Справочники["ВетеринарноСопроводительныйДокументВЕТИС"]);
		СписокОбъектов.Добавить(Документы["ВходящаяТранспортнаяОперацияВЕТИС"]);
		СписокОбъектов.Добавить(Документы["ИнвентаризацияПродукцииВЕТИС"]);
		СписокОбъектов.Добавить(Документы["ИсходящаяТранспортнаяОперацияВЕТИС"]);
		СписокОбъектов.Добавить(Документы["ЗапросСкладскогоЖурналаВЕТИС"]);
		СписокОбъектов.Добавить(Документы["ПроизводственнаяОперацияВЕТИС"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ГИСМ") Тогда
		СписокОбъектов.Добавить(Документы["ПеремаркировкаТоваровГИСМ"]);
		СписокОбъектов.Добавить(Документы["МаркировкаТоваровГИСМ"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		СписокОбъектов.Добавить(Документы["АктПостановкиНаБалансЕГАИС"]);
		СписокОбъектов.Добавить(Документы["АктСписанияЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ВозвратИзРегистра2ЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ЗапросАкцизныхМарокЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ТранспортнаяНакладнаяЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ОстаткиЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ОтчетЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ПередачаВРегистр2ЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ЧекЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ЧекЕГАИСВозврат"]);
		СписокОбъектов.Добавить(Документы["ТТНИсходящаяЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ТТНВходящаяЕГАИС"]);
		СписокОбъектов.Добавить(Обработки["ПечатьРазделаБСправкиТТН"]);
		СписокОбъектов.Добавить(Документы["ТранспортнаяНакладнаяЕГАИС"]);
		СписокОбъектов.Добавить(Документы["УведомлениеОПланируемомИмпортеЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ОтчетОбИмпортеЕГАИС"]);
		СписокОбъектов.Добавить(Документы["ОтчетОПроизводствеЕГАИС"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		СписокОбъектов.Добавить(Документы["МаркировкаТоваровИСМП"]);
		СписокОбъектов.Добавить(Документы["ОтгрузкаТоваровИСМП"]);
		СписокОбъектов.Добавить(Документы["ПриемкаТоваровИСМП"]);
		СписокОбъектов.Добавить(Документы["ВыводИзОборотаИСМП"]);
		СписокОбъектов.Добавить(Документы["ВозвратВОборотИСМП"]);
		СписокОбъектов.Добавить(Документы["ЗаказНаЭмиссиюКодовМаркировкиСУЗ"]);
		СписокОбъектов.Добавить(Документы["ПеремаркировкаТоваровИСМП"]);
		СписокОбъектов.Добавить(Документы["СписаниеКодовМаркировкиИСМП"]);
		СписокОбъектов.Добавить(Документы["УточнениеСведенийОКодахМаркировкиИСМП"]);
		СписокОбъектов.Добавить(Документы["ОтчетИСМП"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЗЕРНО") Тогда
		СписокОбъектов.Добавить(Документы["ФормированиеПартийЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["ОформлениеСДИЗЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["ВнесениеСведенийОСобранномУрожаеЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["СписаниеПартийЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["ПогашениеСДИЗЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["ФормированиеПартийИзДругихПартийЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["ФормированиеПартийПриПроизводствеЗЕРНО"]);
		СписокОбъектов.Добавить(Документы["ЗапросОстатковПартийЗЕРНО"]);
		СписокОбъектов.Добавить(Справочники["СДИЗЗЕРНО"]);
		СписокОбъектов.Добавить(Справочники["ДоговорыХраненияПартийЗЕРНО"]);
		СписокОбъектов.Добавить(Справочники["РеестрМестФормированияПартийЗЕРНО"]);
		СписокОбъектов.Добавить(Справочники["РезультатыИсследованийЗЕРНО"]);
		СписокОбъектов.Добавить(Справочники["РеестрПартийЗЕРНО"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.САТУРН") Тогда
		СписокОбъектов.Добавить(Документы["АктИнвентаризацииСАТУРН"]);
		СписокОбъектов.Добавить(Документы["АктПримененияСАТУРН"]);
		СписокОбъектов.Добавить(Документы["ЗапросОстатковПартийСАТУРН"]);
		СписокОбъектов.Добавить(Документы["ИмпортПродукцииСАТУРН"]);
		СписокОбъектов.Добавить(Документы["НакладнаяСАТУРН"]);
		СписокОбъектов.Добавить(Документы["ПланПримененияСАТУРН"]);
		СписокОбъектов.Добавить(Документы["ПроизводственнаяОперацияСАТУРН"]);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОпределитьОбъектыСКомандамиОтчетов(Объекты) Экспорт
	
	Объекты.Добавить(Метаданные.Справочники.ШтрихкодыУпаковокТоваров);
	мДокументы = Метаданные.Документы;
	мСправочники = Метаданные.Справочники;
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		Объекты.Добавить(мДокументы["АктПостановкиНаБалансЕГАИС"]);
		Объекты.Добавить(мДокументы["АктСписанияЕГАИС"]);
		Объекты.Добавить(мДокументы["ЗапросАкцизныхМарокЕГАИС"]);
		Объекты.Добавить(мДокументы["ВозвратИзРегистра2ЕГАИС"]);
		Объекты.Добавить(мДокументы["ОстаткиЕГАИС"]);
		Объекты.Добавить(мДокументы["ПередачаВРегистр2ЕГАИС"]);
		Объекты.Добавить(мДокументы["ТТНВходящаяЕГАИС"]);
		Объекты.Добавить(мДокументы["ТТНИсходящаяЕГАИС"]);
		Объекты.Добавить(мДокументы["ЧекЕГАИС"]);
		Объекты.Добавить(мДокументы["ЧекЕГАИСВозврат"]);
		Объекты.Добавить(мДокументы["ОтчетЕГАИС"]);
		Объекты.Добавить(мДокументы["ТранспортнаяНакладнаяЕГАИС"]);
		Объекты.Добавить(мДокументы["УведомлениеОПланируемомИмпортеЕГАИС"]);
		Объекты.Добавить(мДокументы["ОтчетОбИмпортеЕГАИС"]);
		Объекты.Добавить(мДокументы["ОтчетОПроизводствеЕГАИС"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ВетИС") Тогда
		Объекты.Добавить(мДокументы["ВходящаяТранспортнаяОперацияВЕТИС"]);
		Объекты.Добавить(мДокументы["ИсходящаяТранспортнаяОперацияВЕТИС"]);
		Объекты.Добавить(мДокументы["ЗапросСкладскогоЖурналаВЕТИС"]);
		Объекты.Добавить(мДокументы["ИнвентаризацияПродукцииВЕТИС"]);
		Объекты.Добавить(мДокументы["ПроизводственнаяОперацияВЕТИС"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		Объекты.Добавить(мДокументы["МаркировкаТоваровИСМП"]);
		Объекты.Добавить(мДокументы["ВыводИзОборотаИСМП"]);
		Объекты.Добавить(мДокументы["ВозвратВОборотИСМП"]);
		Объекты.Добавить(мДокументы["ЗаказНаЭмиссиюКодовМаркировкиСУЗ"]);
		Объекты.Добавить(мДокументы["ПеремаркировкаТоваровИСМП"]);
		Объекты.Добавить(мДокументы["СписаниеКодовМаркировкиИСМП"]);
		Объекты.Добавить(мДокументы["ОтгрузкаТоваровИСМП"]);
		Объекты.Добавить(мДокументы["ПриемкаТоваровИСМП"]);
		Объекты.Добавить(мДокументы["УточнениеСведенийОКодахМаркировкиИСМП"]);
		Объекты.Добавить(мДокументы["ОтчетИСМП"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЗЕРНО") Тогда
		Объекты.Добавить(мДокументы["ФормированиеПартийЗЕРНО"]);
		Объекты.Добавить(мДокументы["ОформлениеСДИЗЗЕРНО"]);
		Объекты.Добавить(мДокументы["ВнесениеСведенийОСобранномУрожаеЗЕРНО"]);
		Объекты.Добавить(мДокументы["СписаниеПартийЗЕРНО"]);
		Объекты.Добавить(мДокументы["ПогашениеСДИЗЗЕРНО"]);
		Объекты.Добавить(мДокументы["ФормированиеПартийИзДругихПартийЗЕРНО"]);
		Объекты.Добавить(мДокументы["ЗапросОстатковПартийЗЕРНО"]);
		Объекты.Добавить(мДокументы["ФормированиеПартийПриПроизводствеЗЕРНО"]);
		Объекты.Добавить(мСправочники["ДоговорыХраненияПартийЗЕРНО"]);
		Объекты.Добавить(мСправочники["РеестрМестФормированияПартийЗЕРНО"]);
		Объекты.Добавить(мСправочники["СДИЗЗЕРНО"]);
		Объекты.Добавить(мСправочники["РезультатыИсследованийЗЕРНО"]);
		Объекты.Добавить(мСправочники["РеестрПартийЗЕРНО"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.САТУРН") Тогда
		Объекты.Добавить(мДокументы["АктИнвентаризацииСАТУРН"]);
		Объекты.Добавить(мДокументы["АктПримененияСАТУРН"]);
		Объекты.Добавить(мДокументы["ИмпортПродукцииСАТУРН"]);
		Объекты.Добавить(мДокументы["НакладнаяСАТУРН"]);
		Объекты.Добавить(мДокументы["ПланПримененияСАТУРН"]);
		Объекты.Добавить(мДокументы["ПроизводственнаяОперацияСАТУРН"]);
		Объекты.Добавить(мДокументы["ЗапросОстатковПартийСАТУРН"]);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ГИСМ") Тогда
		Объекты.Добавить(мДокументы["ЗаявкаНаВыпускКиЗГИСМ"]);
		Объекты.Добавить(мДокументы["МаркировкаТоваровГИСМ"]);
		Объекты.Добавить(мДокументы["ПеремаркировкаТоваровГИСМ"]);
		Объекты.Добавить(мДокументы["УведомлениеОбИмпортеМаркированныхТоваровГИСМ"]);
		Объекты.Добавить(мДокументы["УведомлениеОбОтгрузкеМаркированныхТоваровГИСМ"]);
		Объекты.Добавить(мДокументы["УведомлениеОВвозеМаркированныхТоваровИзЕАЭСГИСМ"]);
		Объекты.Добавить(мДокументы["УведомлениеОПоступленииМаркированныхТоваровГИСМ"]);
		Объекты.Добавить(мДокументы["УведомлениеОСписанииКиЗГИСМ"]);
	КонецЕсли;
	
КонецПроцедуры

Процедура НастроитьВариантыОтчетов(Настройки) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОтчетыЕГАИС");
		Модуль.НастроитьВариантыОтчетов(Настройки);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ВЕТИС") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияВЕТИС");
		Модуль.НастроитьВариантыОтчетов(Настройки);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОтчетыИСМП");
		Модуль.НастроитьВариантыОтчетов(Настройки);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЗЕРНО") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЗЕРНО");
		Модуль.НастроитьВариантыОтчетов(Настройки);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.САТУРН") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияСАТУРН");
		Модуль.НастроитьВариантыОтчетов(Настройки);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Обмен

// Получает сертификаты организаций, для предназначены для подписания на сервере.
// 
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//   * Сертификаты - ТаблицаЗначений - содержит сертификат и пароль.
//   * МенеджерКриптографии - МенеджерКриптографии - менеджер криптографии.
//
Функция СертификатыДляПодписанияНаСервере() Экспорт
	
	Если Не ОбщегоНазначения.ИнформационнаяБазаФайловая()
		И Не ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкиОбмена = НастройкиОбменаГосИС();
	
	Если НастройкиОбмена = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НастройкиОбмена.Колонки.Найти("Подразделение") = Неопределено Тогда
		НастройкиОбмена.Колонки.Добавить("Подразделение", ОпределяемыеТипы().Подразделение.Тип);
	КонецЕсли;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Т.Организация   КАК Организация,
	|	Т.Подразделение КАК Подразделение,
	|	Т.Сертификат    КАК Сертификат
	|ПОМЕСТИТЬ ТаблицаДанных
	|ИЗ
	|	&Таблица КАК Т
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаДанных.Организация          КАК Организация,
	|	ТаблицаДанных.Подразделение        КАК Подразделение,
	|	ТаблицаДанных.Сертификат           КАК Сертификат,
	|	ТаблицаДанных.Сертификат.Отпечаток КАК Отпечаток,
	|	ТаблицаДанных.Сертификат.Программа КАК Программа
	|ИЗ
	|	ТаблицаДанных КАК ТаблицаДанных
	|ГДЕ
	|	НЕ ТаблицаДанных.Сертификат.Отозван
	|	И (ТаблицаДанных.Сертификат.ДействителенДо >= &ТекущаяДатаСеанса
	|	   ИЛИ ТаблицаДанных.Сертификат.ДействителенДо = ДАТАВРЕМЯ(1, 1, 1))
	|");
	
	Запрос.УстановитьПараметр("Таблица",           НастройкиОбмена);
	Запрос.УстановитьПараметр("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	
	ДанныеСертификатовИзНастроекОбмена = Запрос.Выполнить().Выгрузить();
	
	СертификатыОрганизацийДляОбменаНаСервере = Новый ТаблицаЗначений();
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Организация");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Подразделение");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Сертификат");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Отпечаток");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("СертификатКриптографии");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Пароль");
	
	СертификатыОрганизацийДляОбменаНаСервере.Индексы.Добавить("Организация");
	СертификатыОрганизацийДляОбменаНаСервере.Индексы.Добавить("Организация,Подразделение");
	
	Программа = Неопределено;
	Для Каждого ДанныеСертификата Из ДанныеСертификатовИзНастроекОбмена Цикл
		
		Пароль = ПарольКСертификату(ДанныеСертификата.Сертификат);
		
		СертификатКриптографии = ЭлектроннаяПодписьСлужебный.ПолучитьСертификатПоОтпечатку(
			ДанныеСертификата.Отпечаток,
			Ложь,
			Ложь);
		Если СертификатКриптографии = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаТЧ = СертификатыОрганизацийДляОбменаНаСервере.Добавить();
		СтрокаТЧ.Организация            = ДанныеСертификата.Организация;
		СтрокаТЧ.Подразделение          = ДанныеСертификата.Подразделение;
		СтрокаТЧ.Сертификат             = ДанныеСертификата.Сертификат;
		СтрокаТЧ.Отпечаток              = ДанныеСертификата.Отпечаток;
		СтрокаТЧ.СертификатКриптографии = СертификатКриптографии;
		Если Пароль <> Неопределено Тогда
			СтрокаТЧ.Пароль = Пароль;
		Иначе
			СтрокаТЧ.Пароль = "";
		КонецЕсли;
		
		Программа = ДанныеСертификата.Программа;
		
	КонецЦикла;
	
	Если СертификатыОрганизацийДляОбменаНаСервере.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МенеджерКриптографии = ЭлектроннаяПодпись.МенеджерКриптографии("Подписание",,, Программа);
	
	СертификатыДляПодписанияНаСервере = Новый Структура;
	СертификатыДляПодписанияНаСервере.Вставить("Сертификаты",          СертификатыОрганизацийДляОбменаНаСервере);
	СертификатыДляПодписанияНаСервере.Вставить("МенеджерКриптографии", МенеджерКриптографии);
	
	Возврат СертификатыДляПодписанияНаСервере;
	
КонецФункции

// Получает доступные пользователю для подписи сертификаты по организации.
//
// Параметры:
//  Организация - ОпределяемыйТип.Организация - организация, чьи сертификаты получаются.
//  ВключатьСертификатыБезОрганизации - Булево - Включать сертификаты с незаполненной организацией, если отсутсвуют сертификаты организации.
// Возвращаемое значение:
//   Массив из СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - массив доступных сертификатов.
//
Функция СертификатыПользователяДляПодписиПоОрганизации(Организация, ВключатьСертификатыБезОрганизации = Ложь) Экспорт
	
	Организации = Новый Массив;
	Организации.Добавить(Организация);
	
	Возврат СертификатыПользователяДляПодписиПоОрганизациям(Организации, ВключатьСертификатыБезОрганизации)[Организация];
	
КонецФункции

// Получает доступные пользователю для подписи сертификаты по организациям.
//
// Параметры:
//  Организации - Массив из ОпределяемыйТип.Организация - организация, чьи сертификаты получаются.
//  ВключатьСертификатыБезОрганизации - Булево - Включать сертификаты с незаполненной организацией, если отсутсвуют сертификаты организации.
// Возвращаемое значение:
//   Соответствие из КлючИЗначение:
//   * Ключ - ОпределяемыйТип.Организация - организация.
//   * Значение - Массив из СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - массив доступных сертификатов.
//
Функция СертификатыПользователяДляПодписиПоОрганизациям(Организации, ВключатьСертификатыБезОрганизации = Ложь) Экспорт
	
	Результат = Новый Соответствие;
	Для Каждого Организация Из Организации Цикл
		Результат.Вставить(Организация, Новый Массив);
	КонецЦикла;
	
	ЕстьПравоДоступаЧтение = ПравоДоступа("Чтение", Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования);
	Если Не ЕстьПравоДоступаЧтение Тогда
		Возврат Результат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	Сертификаты.Организация КАК Организация,
	|	Сертификаты.Ссылка КАК Сертификат
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Пользователи КАК ПользователиСертификатов
	|		ПО Сертификаты.Ссылка = ПользователиСертификатов.Ссылка
	|ГДЕ
	|	Сертификаты.Организация В (&Организации)
	|	И НЕ Сертификаты.Отозван
	|	И НЕ Сертификаты.ПометкаУдаления
	|	И (Сертификаты.ДействителенДо >= &ТекущаяДатаСеанса
	|			ИЛИ Сертификаты.ДействителенДо = ДАТАВРЕМЯ(1, 1, 1))
	|	И (Сертификаты.Пользователь = &Пользователь
	|			ИЛИ ПользователиСертификатов.Пользователь = &Пользователь
	|			ИЛИ Сертификаты.Пользователь В (&ПустойПользователь)
	|				И ПользователиСертификатов.Пользователь ЕСТЬ NULL)
	|;
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	Сертификаты.Ссылка КАК Сертификат
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Пользователи КАК ПользователиСертификатов
	|		ПО Сертификаты.Ссылка = ПользователиСертификатов.Ссылка
	|ГДЕ
	|	ВЫБОР
	|		КОГДА &ВключатьСертификатыБезОрганизации
	|			ТОГДА Сертификаты.Организация В (&ПустаяОрганизация)
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ
	|	И НЕ Сертификаты.Отозван
	|	И НЕ Сертификаты.ПометкаУдаления
	|	И (Сертификаты.ДействителенДо >= &ТекущаяДатаСеанса
	|			ИЛИ Сертификаты.ДействителенДо = ДАТАВРЕМЯ(1, 1, 1))
	|	И (Сертификаты.Пользователь = &Пользователь
	|			ИЛИ ПользователиСертификатов.Пользователь = &Пользователь
	|			ИЛИ Сертификаты.Пользователь В (&ПустойПользователь)
	|				И ПользователиСертификатов.Пользователь ЕСТЬ NULL)";
	
	Запрос.УстановитьПараметр("ТекущаяДатаСеанса",                 ТекущаяДатаСеанса());
	Запрос.УстановитьПараметр("ВключатьСертификатыБезОрганизации", ВключатьСертификатыБезОрганизации);
	Запрос.УстановитьПараметр("Организации",                       Организации);
	Запрос.УстановитьПараметр("ПустаяОрганизация",                 НезаполненныеЗначенияОпределяемогоТипа("Организация"));
	Запрос.УстановитьПараметр("Пользователь",                      Пользователи.ТекущийПользователь());
	Запрос.УстановитьПараметр("ПустойПользователь",                НезаполненныеЗначенияОпределяемогоТипа("Пользователь"));
	Запрос.Параметры.ПустойПользователь.Добавить(Пользователи.СсылкаНеуказанногоПользователя());
	
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатЗапроса[0].Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат[Выборка.Организация].Добавить(Выборка.Сертификат);
	КонецЦикла;
	
	Если ВключатьСертификатыБезОрганизации Тогда
		Выборка = РезультатЗапроса[1].Выбрать();
		Для Каждого КлючИЗначение Из Результат Цикл
			Если КлючИЗначение.Значение.Количество() = 0 Тогда
				Выборка.Сбросить();
				Пока Выборка.Следующий() Цикл
					КлючИЗначение.Значение.Добавить(Выборка.Сертификат);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

// Получает список доступных для использования организаций.
//
//Возвращаемое значение:
//   СписокЗначений Из ОпределяемыйТип.Организация - ссылки на организации:
//    * Значение      - ОпределяемыйТип.Организация - ссылка на организацию.
//    * Представление - Строка - наименование организации.
Функция ДоступныеОрганизации() Экспорт
	
	СписокОрганизаций = Новый Массив;
	ИнтеграцияИСПереопределяемый.ПриОпределенииСпискаОрганизацийНедоступныхДляВыбора(СписокОрганизаций);
	
	Организации = Новый СписокЗначений;
	
	ШаблонЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка       КАК Ссылка,
	|	Организации.Наименование КАК Наименование
	|ИЗ
	|	%1 КАК Организации
	|ГДЕ
	|	НЕ (Организации.Ссылка В (&СписокОрганизаций))
	|";
	
	Объединение = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";

	Порядок = "
	|УПОРЯДОЧИТЬ ПО
	|	Организации.Наименование";
	
	ТекстЗапроса = "";
	ТипыОрганизаций = ОпределяемыеТипы().Организация.Тип.Типы();
	ПерваяИтерация = Истина;
	
	Для Каждого Тип Из ТипыОрганизаций Цикл
		
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонЗапроса, ПолноеИмя) + ?(Не ПерваяИтерация, Объединение, "");
		ПерваяИтерация = Ложь;
		
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + Порядок;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("СписокОрганизаций", СписокОрганизаций);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Организации.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;
	
	Возврат Организации;
	
КонецФункции

Функция ДатыЗапретаИзмененияИзменениеЗапрещено(ПроверяемыйДокумент) Экспорт

	ВозвращаемоеЗначение = Ложь;

	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ДатыЗапретаИзменения") Тогда

		МодульДатыЗапретаИзменения                 = ОбщегоНазначения.ОбщийМодуль("ДатыЗапретаИзменения");
		МодульДатыЗапретаИзмененияПереопределяемый = ОбщегоНазначения.ОбщийМодуль("ДатыЗапретаИзмененияПереопределяемый");

		// Обход ошибки БСП, когда форма может вызываться для объектов подключенных и не подключенных к подсистеме
		ИсточникиДанных = Новый ТаблицаЗначений;
		ИсточникиДанных.Колонки.Добавить("Таблица",     Новый ОписаниеТипов("Строка"));
		ИсточникиДанных.Колонки.Добавить("ПолеДаты",    Новый ОписаниеТипов("Строка"));
		ИсточникиДанных.Колонки.Добавить("Раздел",      Новый ОписаниеТипов("Строка"));
		ИсточникиДанных.Колонки.Добавить("ПолеОбъекта", Новый ОписаниеТипов("Строка"));
		ИсточникиДанных.Индексы.Добавить("Таблица");
		УстановитьПривилегированныйРежим(Истина);
		МодульДатыЗапретаИзмененияПереопределяемый.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных);
		УстановитьПривилегированныйРежим(Ложь);
		
		МетаданныеОбъекта = ПроверяемыйДокумент.Метаданные();
		ПолноеИмя = МетаданныеОбъекта.ПолноеИмя();

		Если ИсточникиДанных.Найти(ПолноеИмя, "Таблица") <> Неопределено
			И МодульДатыЗапретаИзменения.ИзменениеЗапрещено(ПолноеИмя, ПроверяемыйДокумент) Тогда
			ВозвращаемоеЗначение = Истина;
		КонецЕсли;

	КонецЕсли;

	Возврат ВозвращаемоеЗначение;

КонецФункции

#Область ФункцииИспользующиеПереопределение

#Область Номенклатура

Функция ТекстЗапросаПризнакаМаркируемаяПродукцияПоНоменклатуре(ИмяТаблицыНоменклатура = "Товары", ИмяПоляНоменклатура = "Номенклатура") Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ПриЗаполненииТекстаЗапросаПризнакаМаркируемаяПродукцияПоНоменклатуре(ТекстЗапроса, ИмяТаблицыНоменклатура, ИмяПоляНоменклатура);
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ПравоРегистрацииШтрихкодовНоменклатуры() Экспорт
	
	ПравоДоступа = Ложь;
	ИнтеграцияИСПереопределяемый.ПравоРегистрацииШтрихкодовНоменклатуры(ПравоДоступа);
	Возврат ПравоДоступа;
	
КонецФункции

//Формирует представление строки номенклатуры. Переопределяется.
//   Значение по-умолчанию: непустые представления составляющих, через запятую.
//
//Параметры:
//   Номенклатура   - ОпределяемыйТип.Номенклатура               - ссылка на номенклатуру.
//   Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - ссылка на характеристику номенклатуры.
//   Упаковка       - ОпределяемыйТип.Упаковка                   - ссылка на упаковку.
//   Серия          - ОпределяемыйТип.СерияНоменклатуры          - ссылка на серию номенклатуры.
//   ПоУмолчанию    - Строка                                     - Значение, если номенклатура не заполнена.
//
//Возвращаемое значение:
//   Строка - представление строки номенклатуры
//
Функция ПредставлениеНоменклатуры(Номенклатура, Характеристика, Упаковка = Неопределено, Серия = Неопределено, ПоУмолчанию = Неопределено) Экспорт
	
	Представление = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьПредставлениеНоменклатуры(
		Представление, Номенклатура, Характеристика, Упаковка, Серия);
	
	Если Представление = "" Тогда
		МассивФормированияПредставления = Новый Массив;
		Если ЗначениеЗаполнено(Номенклатура) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Номенклатура));
		КонецЕсли;
		Если ЗначениеЗаполнено(Характеристика) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Характеристика));
		КонецЕсли;
		Если ЗначениеЗаполнено(Упаковка) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Упаковка));
		КонецЕсли;
		Если ЗначениеЗаполнено(Серия) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Серия));
		КонецЕсли;
		Представление = СтрСоединить(МассивФормированияПредставления, ", ");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Представление) И ЗначениеЗаполнено(ПоУмолчанию) Тогда
		Представление = Строка(ПоУмолчанию);
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

#Область ХарактеристикиНоменклатуры

Функция ПризнакИспользованияХарактеристик(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеХарактеристик(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

Функция ХарактеристикиИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеХарактеристик(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

Функция ИспользуетсяЧастичноеВыбытие(ВидПродукцииИС = Неопределено) Экспорт
	
	Если ВидПродукцииИС = Неопределено Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	1
		|ИЗ
		|	РегистрСведений.ОписаниеНоменклатурыИС КАК ОписаниеНоменклатурыИС
		|ГДЕ
		|	ОписаниеНоменклатурыИС.ВариантЧастичногоВыбытия <> ЗНАЧЕНИЕ(Перечисление.ВариантыУчетаЧастичногоВыбытияИС.ПустаяСсылка)
		|";
		Возврат Не Запрос.Выполнить().Пустой();
	КонецЕсли;
	
	Используется = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеЧастичноеВыбытие(Используется, ВидПродукцииИС);
	Возврат Используется;
	
КонецФункции

Функция ЕстьПроизвольныеЕдиницыУчета(ВидПродукцииИС = Неопределено) Экспорт
	
	Если ВидПродукцииИС = Неопределено Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	1
		|ИЗ
		|	РегистрСведений.ОписаниеНоменклатурыИС КАК ОписаниеНоменклатурыИС
		|ГДЕ
		|	ОписаниеНоменклатурыИС.КоличествоВПотребительскойУпаковке <> 1
		|	Или ОписаниеНоменклатурыИС.ЕмкостьПотребительскойУпаковки > 1
		|";
		Если Не Запрос.Выполнить().Пустой() Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Используется = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеПроизвольныхЕдиницУчета(Используется, ВидПродукцииИС);
	Возврат Используется;
	
КонецФункции

Функция ЕстьПродукцияТребующаяВзвешивания() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	1
	|ИЗ
	|	РегистрСведений.ОписаниеНоменклатурыИС КАК ОписаниеНоменклатурыИС
	|ГДЕ
	|	ОписаниеНоменклатурыИС.КоличествоВПотребительскойУпаковке = 0";
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Используется = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеПродукцииТребующейВзвешивания(Используется);
	Возврат Используется;
	
КонецФункции

// Работа с регистром "ОписаниеНоменклатурыИС", при незаполненном переопределении библиотечный сценарий
//
// Параметры:
//  ТекстЗапроса          - Строка - текст запроса с регистром "ОписаниеНоменклатурыИС" (исходящий),
//  ПутьКРегистру         - Строка - имя таблицы регистра "ОписаниеНоменклатурыИС" в запросе,
//  ПутьКПолюНоменклатура - Строка - путь к номенклатуре в запросе
Процедура ОбновитьТекстЗапросаСРегистромОписаниеНоменклатурыИС(ТекстЗапроса, ПутьКРегистру, ПутьКПолюНоменклатура) Экспорт
	
	ИнтеграцияИСПереопределяемый.ОбновитьТекстЗапросаСРегистромОписаниеНоменклатурыИС(ТекстЗапроса,
		ПутьКРегистру, ПутьКПолюНоменклатура);
	// Соединение с регистром
	ИмяПоляЗамены = "&ТоварыОписаниеНоменклатурыИС";
	ТекстЗамены = СтрШаблон("%2.Номенклатура = %1", ПутьКПолюНоменклатура, ПутьКРегистру);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ТекстЗамены);
	// Получение признака Произвольная единица учета
	ИмяПоляЗамены = "&ПроизвольнаяЕдиницаУчета";
	ТекстЗамены = СтрШаблон("ЕСТЬNULL(%1.КоличествоВПотребительскойУпаковке, 1) <> 1
	|	ИЛИ ЕСТЬNULL(%1.ЕмкостьПотребительскойУпаковки, 1) > 1", ПутьКРегистру);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ТекстЗамены);
	// Получение признака Требует взвешивания
	ИмяПоляЗамены = "&ТребуетВзвешивания";
	ТекстЗамены = СтрШаблон("ЕСТЬNULL(%1.КоличествоВПотребительскойУпаковке, 1) = 0", ПутьКРегистру);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ТекстЗамены);
	
КонецПроцедуры

#КонецОбласти

#Область Описаниеноменклатуры

#Область СерииНоменклатуры

Функция СерииИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеСерий(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

Функция ПризнакИспользованияСерий(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеСерий(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

// Возвращает параметры указания серий для товаров, указанных в объекте.
//
// Параметры:
//	Объект   - ДанныеФормыСтруктура - Объект, для формы которого нужно сформировать параметры указания серий.
//	Менеджер - Произвольный - Менеджер объекта, для формы которого нужно сформировать параметры указания серий.
//
// Возвращаемое значение:
//	Произвольный - параметры, уточняющие особенности указания серий в каждом объекте
//
Функция ПараметрыУказанияСерийФормыОбъекта(Объект, Менеджер) Экспорт
	
	Параметры = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерийФормыОбъекта(Параметры, Объект, Менеджер);
	Возврат Параметры;
	
КонецФункции

// Имена реквизитов, от значений которых зависят параметры указания серий.
//
// Возвращаемое значение:
//	Строка - Имена реквизитов, перечисленные через запятую.
//
Функция ИменаРеквизитовДляЗаполненияПараметровУказанияСерий(ТипОбъекта) Экспорт
	
	ИменаРеквизитов = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьИменаРеквизитовДляЗаполненияПараметровУказанияСерий(ИменаРеквизитов, ТипОбъекта);
	Возврат ИменаРеквизитов;
	
КонецФункции

//Возвращает параметры указания серий для товаров, указанных в объекте.
//
//Параметры:
//   ТипОбъекта - ОбъектМетаданных - Тип объекта коллекции объектов метаданных.
//   Объект     - Структура        - Структура значений реквизитов объекта, необходимых для заполнения параметров указания серий.
//
// Возвращаемое значение:
//  Произвольный - (См. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий) - особенности указания серий.
//
Функция ПараметрыУказанияСерий(ТипОбъекта, Объект) Экспорт
	
	Параметры = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий(Параметры, ТипОбъекта, Объект);
	Возврат Параметры;
	
КонецФункции

// Возвращает текст запроса заполнения статусов указания серий для товаров, указанных в документе.
//
// Параметры:
//   ТипОбъекта             - ОбъектМетаданных - Тип документа коллекции объектов метаданных.
//   ПараметрыУказанияСерий - см. ПараметрыУказанияСерий.
//
// Возвращаемое значение:
//   Строка - Текст запроса заполнения статусов указания серий для товаров, указанных в объекте.
//
Функция ТекстЗапросаЗаполненияСтатусовУказанияСерий(ТипОбъекта, ПараметрыУказанияСерий) Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьТекстЗапросаЗаполненияСтатусовУказанияСерий(
		ТекстЗапроса,
		ТипОбъекта,
		ПараметрыУказанияСерий);
	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает текст запроса для проверки заполнения серий
//
// Параметры:
//   ТипОбъекта             - ОбъектМетаданных - Тип документа коллекции объектов метаданных.
//   ПараметрыУказанияСерий - см. ПараметрыУказанияСерий
//
// Возвращаемое значение:
//   Строка - текст запроса.
//
Функция ТекстЗапросаПроверкиЗаполненияСерий(ТипОбъекта, ПараметрыУказанияСерий) Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьТекстЗапросаПроверкиЗаполненияСерий(
		ТекстЗапроса,
		ТипОбъекта,
		ПараметрыУказанияСерий);
	Возврат ТекстЗапроса;
	
КонецФункции

// Определяет необходимость указания серии для маркируемой продукции.
// 
// Параметры:
//  Товар - Структура - данные строки номенклатуры. Содержит обязательные поля:
//   * Номенклатура   - ОпределяемыйТип.Номенклатура               - номенклатура,
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - характеристика.
//  ПараметрыСканирования - (См. ШтрихкодированиеИСКлиент.ПараметрыСканирования).
// Возвращаемое значение:
//  Булево - Истина, если требуется указать серию.
Функция ТребуетсяВыборСерии(Товар, ПараметрыСканирования) Экспорт
	
	Если ПараметрыСканирования.ДополнительныеПараметры.Свойство("ДанныеУточнения")
			И ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Свойство("Серия") Тогда
		Возврат ЗначениеЗаполнено(ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Серия);
	КонецЕсли;
	
	ТребуетсяВыбор = Ложь;
	
	Операция = Неопределено;
	Если ШтрихкодированиеИС.ДопустимаПродукцияИСМП(ПараметрыСканирования)
			Или ШтрихкодированиеИС.ДопустимаТабачнаяПродукция(ПараметрыСканирования) Тогда
		Операция = ПараметрыСканирования.ВидОперацииИСМП;
	ИначеЕсли ПараметрыСканирования.ДопустимыеВидыПродукции.Найти(Перечисления.ВидыПродукцииИС.Алкогольная) <> Неопределено Тогда
		Операция = ПараметрыСканирования.Операция;
	КонецЕсли;
	
	ПараметрыУказанияСерий = ПараметрыСканирования.ПараметрыУказанияСерий;
	
	ДанныеДляРасчетаСерии  = Новый Структура;
	ДанныеДляРасчетаСерии.Вставить("Склад",          ПараметрыСканирования.Склад);
	ДанныеДляРасчетаСерии.Вставить("Операция",       Операция);
	ДанныеДляРасчетаСерии.Вставить("Номенклатура",   Товар.Номенклатура);
	ДанныеДляРасчетаСерии.Вставить("Характеристика", Товар.Характеристика);
	
	ИнтеграцияИСПереопределяемый.ПриОпределенииНеобходимостиВыбораСерии(
		ДанныеДляРасчетаСерии, ПараметрыУказанияСерий, ТребуетсяВыбор, Неопределено, ПараметрыСканирования.КэшированныеЗначения);
	
	Возврат ТребуетсяВыбор;
	
КонецФункции

// Определяет необходимость обязательного указания серии для маркируемой продукции.
// 
// Параметры:
//  Товар - Структура - данные строки номенклатуры. Содержит обязательные поля:
//   * Номенклатура   - ОпределяемыйТип.Номенклатура               - номенклатура,
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - характеристика.
//  ПараметрыСканирования - (См. ШтрихкодированиеИСКлиент.ПараметрыСканирования).
// Возвращаемое значение:
//  Булево - Истина, если серия обязательно должна быть заполнена.
Функция СерияДолжнаБытьУказана(Товар, ПараметрыСканирования) Экспорт
	
	Если ПараметрыСканирования.ДополнительныеПараметры.Свойство("ДанныеУточнения")
			И ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Свойство("Серия") Тогда
		Возврат ЗначениеЗаполнено(ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Серия);
	КонецЕсли;
	
	СерияДолжнаБытьУказана = Ложь;
	
	Операция = Неопределено;
	Если ШтрихкодированиеИС.ДопустимаПродукцияИСМП(ПараметрыСканирования)
			Или ШтрихкодированиеИС.ДопустимаТабачнаяПродукция(ПараметрыСканирования) Тогда
		Операция = ПараметрыСканирования.ВидОперацииИСМП;
	ИначеЕсли ПараметрыСканирования.ДопустимыеВидыПродукции.Найти(Перечисления.ВидыПродукцииИС.Алкогольная) <> Неопределено Тогда
		Операция = ПараметрыСканирования.Операция;
	КонецЕсли;
	
	ПараметрыУказанияСерий = ПараметрыСканирования.ПараметрыУказанияСерий;
	
	ДанныеДляРасчетаСерии  = Новый Структура;
	ДанныеДляРасчетаСерии.Вставить("Склад",          ПараметрыСканирования.Склад);
	ДанныеДляРасчетаСерии.Вставить("Операция",       Операция);
	ДанныеДляРасчетаСерии.Вставить("Номенклатура",   Товар.Номенклатура);
	ДанныеДляРасчетаСерии.Вставить("Характеристика", Товар.Характеристика);
	
	ИнтеграцияИСПереопределяемый.ПриОпределенииНеобходимостиВыбораСерии(
		ДанныеДляРасчетаСерии, ПараметрыУказанияСерий, Неопределено, СерияДолжнаБытьУказана, ПараметрыСканирования.КэшированныеЗначения);
	
	Возврат СерияДолжнаБытьУказана;
	
КонецФункции

Функция РезультатГенерацииИЗаполненияСерий() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ЗаполнениеЗавершено",  Ложь);
	Результат.Вставить("СписокОшибок",         Неопределено);
	Возврат Результат;
	
КонецФункции

Функция СгенерироватьСерии(Объект, Товары, ВыделенныеСтроки, ПараметрыУказанияСерий) Экспорт
	
	РезультатЗаполненияСерий = РезультатГенерацииИЗаполненияСерий();
	
	ИнтеграцияИСПереопределяемый.ПриГенерацииСерий(
		Объект,
		Товары,
		ВыделенныеСтроки,
		ПараметрыУказанияСерий,
		РезультатЗаполненияСерий);
		
	Возврат РезультатЗаполненияСерий;
	
КонецФункции

#КонецОбласти

#Область ВидыНоменклатуры

Функция ВидыНоменклатурыИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеВидовНоменклатуры(Используются);
	Возврат Используются;
	
КонецФункции

#КонецОбласти

#Область УпаковкиНоменклатуры

Функция УпаковкиИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеУпаковок(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

Функция ПризнакИспользованияУпаковок(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеУпаковок(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область ОрганизацииКонтрагенты

// Проверяет использование подразделений в информационной базе.
// 
// Возвращаемое значение:
//  Булево - Подразделения используются.
//
Функция ИспользоватьПодразделения() Экспорт
	
	Использовать = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеПодразделений(Использовать);
	Возврат Использовать;
	
КонецФункции

// Определяет использование в инофрмационной базе обособленных подразделений выделенных на отдельный баланс
// 
// Возвращаемое значение:
//  Булево - Используются подразделения, выделенных на обособленный баланс
//
Функция ИспользоватьОбособленныеПодразделенияВыделенныеНаБаланс() Экспорт
	
	Использовать = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользоватьОбособленныеПодразделенияВыделенныеНаБаланс(Использовать);
	Возврат Использовать;
	
КонецФункции

// Выполняет поиск организации предприятия по ИНН и/или КПП.
//
// Параметры:
//   ИНН - Строка - ИНН искомой организации,
//   КПП - Строка - КПП искомой организации.
// 
// Возвращаемое значение:
//   ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено - найденная организация
//
Функция ОрганизацияПоИННКПП(ИНН, КПП) Экспорт
	
	Организация = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьОрганизациюПоИННКПП(Организация, ИНН, КПП);
	Возврат Организация;
	
КонецФункции

// Определяет контрагента по ИНН и КПП
//
// Параметры:
//  ИНН  - Строка - ИНН контрагента.
//  КПП  - Строка - КПП контрагента.
//
// Возвращаемое значение:
//   ОпределяемыйТип.КонтрагентГосИС, ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено  - Найденный контрагент или Неопределено, если поиск завершился неудачей.
//
Функция КонтрагентПоИННКПП(ИНН, КПП) Экспорт
	
	Контрагент = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьКонтрагентаПоИННКПП(Контрагент, ИНН, КПП);
	Возврат Контрагент;
	
КонецФункции

// Возвращает строковое представление руководителя организации.
//
// Параметры:
//  Организация - ОпределяемыйТип.ОрганизацияКонтрагентГосИС - ссылка на собственную организацию или контрагента,
//  ДатаСведений - Дата - дата, на которую требуется получить информацию.
//
// Возвращаемое значение:
//  Структура - данные руководителя:
//   * Руководитель - Строка - ФИО руководителя,
//   * Должность - Строка - должность руководителя.
//
Функция ДанныеРуководителяОрганизации(Организация, ДатаСведений = Неопределено) Экспорт
	
	ПредставлениеРуководителя = Новый Структура("Руководитель, Должность", "", "");
	ИнтеграцияИСПереопределяемый.ОпределитьДанныеРуководителяОрганизации(ПредставлениеРуководителя,Организация,ДатаСведений);
	Возврат ПредставлениеРуководителя;
	
КонецФункции

// Возвращает ссылку на организацию прикладного объекта (документа)
//   Используется в библиотеке для определяемых типов "Основание[Документ]".
//
// Параметры:
//   Объект - Произвольный - объект конфигурации из которого требуется получить организацию
//
// Возвращаемое значение:
//   Неопределено                - отсутствует,
//   ОпределяемыйТип.Организация - ссылка на организацию.
//
Функция ОрганизацияИзПрикладногоОбъекта(Объект) Экспорт
	
	Организация = Неопределено;
	ИнтеграцияИСПереопределяемый.ПриОпределенииОрганизацииИзПрикладногоОбъекта(Организация, Объект);
	Возврат Организация;
	
КонецФункции

// Возвращает структуру, содержащую ИНН, КПП, GLN организации.
//
// Параметры:
//  Организация - ОпределяемыйТип.Организация - Организация.
//  Подразделение - ОпределяемыйТип.Подразделение - Подразделение организации.
//
// Возвращаемое значение:
//  Структура - со свойствами:
//   * ИНН - Строка - ИНН организации.
//   * КПП - Строка - КПП организации.
//   * GLN - Строка - GLN организации.
Функция ИННКППGLNОрганизации(Организация, Подразделение) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИНН", "");
	Результат.Вставить("КПП", "");
	Результат.Вставить("GLN", "");
	ИнтеграцияИСПереопределяемый.ПриОпределенииИННКППGLNОрганизации(Результат, Организация, Подразделение);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПраваДоступа

Функция ЕстьПравоСозданияКонтрагента() Экспорт
	
	ДоступРазрешен = Ложь;
	ИнтеграцияИСПереопределяемый.ПравоСозданияКонтрагента(ДоступРазрешен);
	Возврат  ДоступРазрешен;
	
КонецФункции

#КонецОбласти

Функция ПредставлениеОбъекта(ПараметрОбъект) Экспорт
	
	Представление = НСтр("ru = '<Не задано>'");
	ИнтеграцияИСПереопределяемый.УстановитьПредставлениеОбъекта(Представление, ПараметрОбъект);
	Возврат Представление;
	
КонецФункции

#КонецОбласти

// Возвращает количество строк в дереве значений с учетом их вложенности
// 
// Параметры:
//  ДеревоЗначений - ДеревоЗначений - Дерево значений, в котором требуется определить количество строк
// Возвращаемое значение:
//  Число - количество строк
// 	
Функция КоличествоСтрокДереваЗначений(ДеревоЗначений) Экспорт
	
	СтрокиДерева    = ДеревоЗначений.Строки;
	КоличествоСтрок = СтрокиДерева.Количество();
	
	Для Каждого ПодчиненнаяСтрока Из СтрокиДерева Цикл
		КоличествоСтрок = КоличествоСтрок + КоличествоСтрокДереваЗначений(ПодчиненнаяСтрока);
	КонецЦикла;
	
	Возврат КоличествоСтрок;
	
КонецФункции

// Возвращает признак вхождения переданного объекта метаданных в переданную подсистему
//
// Параметры:
//   ПолноеИмяИлиМетаданныеПодсистемы - Строка           - полное имя подсистемы с учетом родительских подсистем через "."
//                                    - ОбъектМетаданных - сама подсистема
//   ОбъектМетаданных                 - ОбъектМетаданных - объект метаданных для которого определяется принадлежность к подсистеме
//
// Возвращаемое значение:
//   Булево - признак вхождения объекта метаданных в подсистему
//
Функция СодержитсяВПодсистеме(ПолноеИмяИлиМетаданныеПодсистемы, ОбъектМетаданных) Экспорт
	
	Если ТипЗнч(ПолноеИмяИлиМетаданныеПодсистемы) = Тип("Строка") Тогда
		
		ИменаПодсистем = СтрРазделить(ПолноеИмяИлиМетаданныеПодсистемы, ".");
		Если ИменаПодсистем.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		
		МетаданныеПодсистемы = Метаданные;
		
		Для Каждого ИмяПодсистемы Из ИменаПодсистем Цикл
			МетаданныеПодсистемы = МетаданныеПодсистемы.Подсистемы[ИмяПодсистемы];
		КонецЦикла;
		
	Иначе
		
		МетаданныеПодсистемы = ПолноеИмяИлиМетаданныеПодсистемы;
		
	КонецЕсли;
	
	Если МетаданныеПодсистемы.Состав.Содержит(ОбъектМетаданных) Тогда
		Возврат Истина;
	КонецЕсли;

	Для Каждого ПодчиненнаяПодсистема Из МетаданныеПодсистемы.Подсистемы Цикл
		Если СодержитсяВПодсистеме(ПодчиненнаяПодсистема, ОбъектМетаданных) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#Область РаботаСФормойСпискаДокументов

// Устанавливает отбор в списке по указанному значению для нужной колонки
// с учетом переданной структуры быстрого отбора.
//
// Параметры:
//  Список - ТаблицаФормы - динамический список, для которого требуется установить отбор
//  ИмяКолонки - Строка - Имя колонки, по которой устанавливается отбор
//  Значение - Произвольный - устанавливаемое значение отбора
//  СтруктураБыстрогоОтбораРасширенная - Неопределено, Структура - ключи и значения отбора
//  Использование - Неопределено, Булево - Признак использования элемента отбора
//  ВидСравнения - Неопределено, ВидСравненияКомпоновкиДанных - вид сравнения, устанавливаемый для элемента отбора
//  ПриводитьЗначениеКЧислу - Булево - Признак приведения значения к числу.
//
Процедура ОтборПоЗначениюСпискаПриСозданииНаСервере(Список, ИмяКолонки, Значение, Знач СтруктураБыстрогоОтбораРасширенная,
			Использование = Неопределено, ВидСравнения = Неопределено, ПриводитьЗначениеКЧислу = Ложь) Экспорт
	
	Если СтруктураБыстрогоОтбораРасширенная <> Неопределено Тогда
		
		Если СтруктураБыстрогоОтбораРасширенная.Количество() = 2
			И СтруктураБыстрогоОтбораРасширенная.Свойство("ИмяПоля")
			И СтруктураБыстрогоОтбораРасширенная.Свойство("Настройки") Тогда
			СтруктураБыстрогоОтбора = СтруктураБыстрогоОтбораРасширенная.Настройки;
			ИмяКолонкиДляПоиска = СтруктураБыстрогоОтбораРасширенная.ИмяПоля;
		Иначе
			СтруктураБыстрогоОтбора = СтруктураБыстрогоОтбораРасширенная;
			ИмяКолонкиДляПоиска = ИмяКолонки;
		КонецЕсли;
		
		Если СтруктураБыстрогоОтбора <> Неопределено
			И СтруктураБыстрогоОтбора.Свойство(ИмяКолонкиДляПоиска) Тогда
			
			ЗначениеОтбора = СтруктураБыстрогоОтбора[ИмяКолонкиДляПоиска];
			Если ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
				
				Если ТипЗнч(ЗначениеОтбора) = Тип("СписокЗначений") Тогда
					Значение.ЗагрузитьЗначения(ЗначениеОтбора.ВыгрузитьЗначения());
				ИначеЕсли ТипЗнч(ЗначениеОтбора) = Тип("Массив") Тогда
					Значение.ЗагрузитьЗначения(ЗначениеОтбора);
				Иначе
					Значение.Очистить();
					Если ЗначениеЗаполнено(ЗначениеОтбора) Тогда
						Значение.Добавить(ЗначениеОтбора);
					КонецЕсли;
				КонецЕсли;
				
			Иначе
				
				Значение = ЗначениеОтбора;
				
			КонецЕсли;
			
			Если ПриводитьЗначениеКЧислу Тогда
				Значение = ?(ЗначениеЗаполнено(Значение), Число(Значение), Значение);
			КонецЕсли;
			
			Если ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
				ИспользованиеЭлементаОтбора = ?(Использование = Неопределено, Значение.Количество() > 0, Использование);
			Иначе
				ИспользованиеЭлементаОтбора = ?(Использование = Неопределено, ЗначениеЗаполнено(Значение), Использование);
			КонецЕсли;
			
			Если Список <> Неопределено Тогда
				ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(Список, ИмяКолонки, Значение, ВидСравнения,,ИспользованиеЭлементаОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает настройки оформления формы списка документов ГосИС
//
// Возвращаемое значение:
//   Структура - Описание:
// * ЭлементыСтраницы    - Строка           - реквизиты формы - страницы (изменить тип если нет страниц к оформлению)
// * Списки              - Строка           - реквизиты формы - динамические списки документов (через запятую)
// * КОформлению         - Строка           - реквизиты формы - динамические списки к оформлению (через запятую)
// * ТипыКОформлению     - Неопределено     - списки к оформлению безусловно не используются
//                       - ОбъектМетаданных - определяемый тип, документы, для которых используются списки к оформлению
// * ЭлементыКОформлению - Строка           - элементы формы, связанные со списками к оформлению (скрыть если не используются)
// * ТипыКОбмену         - Неопределено     - команда "Выполнить обмен" недоступна
//                       - ОбъектМетаданных - определяемый тип, документы, при праве изменения которых доступна команда "Выполнить обмен"
// * ЭлементыКОбмену     - Строка           - элементы формы реализующие команду "Выполнить обмен" (через запятую)
//
Функция НастройкиФормыСпискаДокументов() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ЭлементыСтраницы",    "Страницы");
	Результат.Вставить("Списки",              "Список");
	Результат.Вставить("КОформлению",         "СписокКОформлению");
	Результат.Вставить("ТипыКОформлению",     Неопределено);
	Результат.Вставить("ЭлементыКОформлению", "СтраницаКОформлению");
	Результат.Вставить("ТипыКОбмену",         Неопределено);
	Результат.Вставить("ЭлементыКОбмену",     "СписокВыполнитьОбмен");
	
	Возврат Результат;
	
КонецФункции

// Обработчик одноименного события в формах списков справочников ГосИС
//
// Параметры:
//   Форма     - ФормаКлиентскогоПриложения - источник события
//
Процедура ПриСозданииНаСервереФормыСпискаСправочников(Форма) Экспорт
	
	ИнтеграцияИСКлиентСервер.НастроитьОтборПоОрганизации(Форма, Форма.Организации, "Отбор");
	
КонецПроцедуры

// Обработчик одноименного события в формах списков документов ГосИС
//
// Параметры:
//   Форма     - ФормаКлиентскогоПриложения - источник события
//   Настройки - См. НастройкиФормыСпискаДокументов
//
Процедура ПриСозданииНаСервереФормыСпискаДокументов(Форма, Настройки) Экспорт
	
	ИмяДокумента = ИнтеграцияИСКлиентСервер.ИмяОбъектаИзИмениФормы(Форма, Ложь);
	ИспользоватьСпискиКОформлению = Настройки.ТипыКОформлению <> Неопределено
		И Настройки.ТипыКОформлению.Тип.СодержитТип(Тип("ДокументСсылка." + ИмяДокумента));
	
	МетаРеквизитОснование      = ИнтеграцияИС.РеквизитДокументОснованиеДокументаИС(Метаданные.Документы[ИмяДокумента]);
	ТипыДокументаОснования     = МетаРеквизитОснование.Тип.Типы();
	СтрокиСоединенияДокументов = Новый Массив;
	СтрокиОтбораДокументов     = Новый Массив;
	ДокументИмеетОснования       = Ложь;
	
	// Подготовим строки соединения и отбора по доступным документам-основаниям.
	Для Каждого ТипОснования Из ТипыДокументаОснования Цикл
		
		МетаданныеОснования = Метаданные.НайтиПоТипу(ТипОснования);
		
		Если МетаданныеОснования = Неопределено Тогда
			Продолжить;
		ИначеЕсли Не Метаданные.Документы.Содержит(МетаданныеОснования) Тогда
			Продолжить;
		Иначе
			ДокументИмеетОснования = Истина;
		КонецЕсли;
		
		Если НЕ ПравоДоступа("Чтение", МетаданныеОснования) Тогда
			Продолжить;
		КонецЕсли;
		
		// Добавим соединение с документом-основанием для RLS.
		СтрокиСоединенияДокументов.Добавить("	ЛЕВОЕ СОЕДИНЕНИЕ Документ." + МетаданныеОснования.Имя + " КАК ДоступКДокументу" + МетаданныеОснования.Имя + "
			|		ПО Таблица.ДокументОснование = ДоступКДокументу" + МетаданныеОснования.Имя + ".Ссылка");
		
		СтрокиОтбораДокументов.Добавить("ДоступКДокументу" + МетаданныеОснования.Имя + ".Ссылка ЕСТЬ НЕ NULL");
		
	КонецЦикла;
	
	Если Не ДокументИмеетОснования Тогда
		
		// Документ не имеет основания
		ТекстСоединения               = "";
		ТекстОтбора                   = " ИЛИ ИСТИНА";
		ТекстОтбораКОформлению        = " И ЛОЖЬ";
		ИспользоватьСпискиКОформлению = Ложь;
		
	ИначеЕсли СтрокиОтбораДокументов.Количество() = 0 Тогда
		
		// Нет ни одного доступного документа-основания.
		ТекстСоединения               = "";
		ТекстОтбора                   = "";
		ТекстОтбораКОформлению        = " И ЛОЖЬ";
		ИспользоватьСпискиКОформлению = Ложь;
		
	Иначе
		
		ТекстСоединения         = СтрСоединить(СтрокиСоединенияДокументов, Символы.ПС);
		ТекстОтбора             = " ИЛИ " + СтрСоединить(СтрокиОтбораДокументов, Символы.ПС + " ИЛИ ");
		ТекстОтбораКОформлению  = " И ЛОЖЬ ИЛИ " + СтрСоединить(СтрокиОтбораДокументов, Символы.ПС + " ИЛИ ");
		
	КонецЕсли;
	
	ИменаВсехСписков                    = Новый Массив;
	СоответствеиИменСписковКОфоррмлению = Новый Соответствие;
	
	Если ЗначениеЗаполнено(Настройки.Списки) Тогда
		ИменаВсехСписков.Добавить(Настройки.Списки);
	КонецЕсли;
	
	СпискиКОформлению = Новый Структура(Настройки.КОформлению);
	
	Если ЗначениеЗаполнено(Настройки.КОформлению) И ИспользоватьСпискиКОформлению Тогда
		ИменаВсехСписков.Добавить(Настройки.КОформлению);
		Для Каждого ИмяСписка Из СпискиКОформлению Цикл
			СоответствеиИменСписковКОфоррмлению.Вставить(СокрЛП(ИмяСписка.Ключ), Истина);
		КонецЦикла;
	КонецЕсли;
	
	ИменаВсехСписков = СтрСоединить(ИменаВсехСписков, ",");
	
	//Выполним общие действия для всех динамических список формы.
	
	Для Каждого ИмяСписка Из Новый Структура(ИменаВсехСписков) Цикл
		
		Список = Форма[ИмяСписка.Ключ];
		
		ОбщегоНазначенияКлиентСервер.УстановитьПараметрДинамическогоСписка(
			Список,
			"ПустойДокументОснование",
			МассивПустыхЗначенийСоставногоТипа(МетаРеквизитОснование.Тип));
		
		ОбщегоНазначенияКлиентСервер.УстановитьПараметрДинамическогоСписка(
			Список,
			"БезОтбораПоОрганизации",
			Истина);
		
		Список.ТекстЗапроса = СтрЗаменить(
			Список.ТекстЗапроса,
			"//%СоединениеСОснованиями%",
			?(СпискиКОформлению.Свойство(ИмяСписка.Ключ),
				СтрЗаменить(ТекстСоединения, ".ДокументОснование", ".Основание"),
				ТекстСоединения));
		
		Если СоответствеиИменСписковКОфоррмлению.Получить(ИмяСписка.Ключ) = Неопределено Тогда
			Список.ТекстЗапроса = СтрЗаменить(
				Список.ТекстЗапроса, "//%ОтборПоДоступнымОснованиям%", ТекстОтбора);
		Иначе
			Список.ТекстЗапроса = СтрЗаменить(
				Список.ТекстЗапроса, "//%ОтборПоДоступнымОснованиям%", ТекстОтбораКОформлению);
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ИспользоватьСпискиКОформлению Тогда
		
		Для Каждого ИмяСписка Из СпискиКОформлению Цикл
			
			Список = Форма[ИмяСписка.Ключ];
			Список.ОсновнаяТаблица = Неопределено;
			Список.ТекстЗапроса = 
			"ВЫБРАТЬ
			|Неопределено КАК Документ,
			|Неопределено КАК Ответственный,
			|Неопределено КАК СтатусОформления
			|ГДЕ ЛОЖЬ"
			
		КонецЦикла;
		
		Для Каждого ИмяЭлемента Из СтрРазделить(Настройки.ЭлементыКОформлению, ",", Ложь) Цикл
			
			Форма.Элементы[ИмяЭлемента].Видимость = Ложь;
			
		КонецЦикла;
		
		Для Каждого ИмяЭлемента Из СтрРазделить(Настройки.ЭлементыСтраницы, ",", Ложь) Цикл
			
			Форма.Элементы[ИмяЭлемента].ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
			
		КонецЦикла;
		
	КонецЕсли;
	
	УстановитьВидимостьКомандыВыполнитьОбмен(Форма, Настройки.ТипыКОбмену, Настройки.ЭлементыКОбмену);
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "Организации") Тогда
		ИнтеграцияИСКлиентСервер.НастроитьОтборПоОрганизации(Форма, Форма.Организации, "Отбор");
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает признак есть ли право на изменение списка документов у текущего пользователя 
//
Процедура УстановитьПризнакПравоИзмененияФормыСписка(ФормаСписка, ИмяРеквизита = "ПравоИзменения") Экспорт
	
	МассивРеквизитовФормы = ФормаСписка.ПолучитьРеквизиты();
	РеквизитНайден = Ложь;
	Для Каждого Реквизит Из МассивРеквизитовФормы Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			РеквизитНайден = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Не РеквизитНайден Тогда
		Возврат;
	КонецЕсли;
	
	ИмяОсновнойТаблицыСписка = ФормаСписка.Список.ОсновнаяТаблица;
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяОсновнойТаблицыСписка);
	ФормаСписка[ИмяРеквизита] = ПравоДоступа("Изменение", ОбъектМетаданных);
	
КонецПроцедуры

#КонецОбласти

#Область КодыТНВЭД

// Определяет текст запроса получения информации по номенклатуре такой как: "МаркируемаяПродукция" и "ВидПродукции" и
// помещает во временную таблицу "СвойстваМаркируемойПродукции".
// 
// Параметры:
// Возвращаемое значение:
// 	Строка - Фрагмент запроса, выборкой которого являются поля: Номенклатура, МаркируемаяПродукция, ВидПродукции.
Функция ОпределитьТекстЗапросаСопоставлениеКодовТНВЭД() Экспорт
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	КодыТНВЭДИСМП.КодТНВЭД           КАК КодТНВЭД,
	|	КодыТНВЭДИСМП.ВидПродукции       КАК ВидПродукции,
	|	КодыТНВЭДИСМП.НаименованиеПолное КАК НаименованиеПолное,
	|	Неопределено                     КАК КодТНВЭДСсылка,
	|	0                                КАК Сопоставлено
	|ИЗ
	|	РегистрСведений.КодыТНВЭДИСМП КАК КодыТНВЭДИСМП";
	
	ИнтеграцияИСПереопределяемый.ПриОпределенииТекстаЗапросаСопоставлениеКодовТНВЭД(ТекстЗапроса);
	
	Возврат ТекстЗапроса;
	
КонецФункции

#КонецОбласти

Функция ОбъединитьПути(Путь1, Путь2, Путь3 = Неопределено) Экспорт
	
	РазделительПути = "\";
	
	МассивПутей = Новый Массив();
	МассивПутей.Добавить(Путь1);
	МассивПутей.Добавить(Путь2);
	МассивПутей.Добавить(Путь3);
	
	МассивПутейИтоговый = Новый Массив();
	
	Для Каждого Путь Из МассивПутей Цикл
		Если Не ЗначениеЗаполнено(Путь) Тогда
			Продолжить;
		КонецЕсли;
		Если Прав(Путь, 1) = "/"
			Или Прав(Путь, 1) = РазделительПути Тогда
			МассивПутейИтоговый.Добавить(Сред(Путь, СтрДлина(Путь) - 1));
		Иначе
			МассивПутейИтоговый.Добавить(Путь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(МассивПутейИтоговый, РазделительПути);

КонецФункции

// Определяет включение режима использования фоновых заданий при обмене с сервисами.
//
// Возвращаемое значение:
//  Булево - Ложь, если фоновые задания не используются.
//
Функция РежимРаботыБезФоновыхЗаданий() Экспорт
	
	ПараметрЗапускаПриложения = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ПараметрЗапуска");
	
	Возврат СтрНайти(ВРег(ПараметрЗапускаПриложения), ВРег("РежимРаботыБезФоновыхЗаданийИС")) > 0;
	
КонецФункции

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ИдентификаторНазначения    - УникальныйИдентификатор, Неопределено - уникальный идентификатор формы для показа сообщения.
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Примеры : см ОбщегоНазначения.СообщитьПользователю.
//
Процедура СообщитьПользователюВФорму(
		Знач ИдентификаторНазначения = Неопределено,
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Если ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
	КонецЕсли;
	
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
	Если КлючДанных <> Неопределено
		И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

Функция УчитываемыеВидыМаркируемойПродукции() Экспорт
	
	ВидыПродукции = Новый Массив;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		ОбщийМодуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЕГАИСВызовСервера");
		ВидыПродукцииЕГАИС = ОбщийМодуль.УчитываемыеВидыМаркируемойПродукции();
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ВидыПродукции, ВидыПродукцииЕГАИС);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		ОбщийМодуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияИСМПВызовСервера");
		ВидыПродукцииИСМП = ОбщийМодуль.УчитываемыеВидыМаркируемойПродукции();
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ВидыПродукции, ВидыПродукцииИСМП);
	КонецЕсли;
	
	Возврат ВидыПродукции;
	
КонецФункции

// Заполняет указанную контактную информацию.
// 
// Параметры:
//  Адрес  - Строка - адрес во внутреннем формате JSON или в XML, соответствующем XDTO-пакету Адрес.
//  Данные - Структура - содержит имена данных, которые необходимо заполнить из строки Адрес.
Процедура ДанныеИзСтрокиКонтактнойИнформации(Адрес, Данные) Экспорт
	
	Если ПустаяСтрока(Адрес) Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеКИ = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияВJSON(Адрес);
	СведенияОбАдресе = РаботаСАдресами.СведенияОбАдресе(ДанныеКИ,,Истина);
	
	ЗаполнитьЗначенияСвойств(Данные, СведенияОбАдресе);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область РаботаСXDTO

// Функция возвращает таблицу значений пользовательских представлений полей из макета
//    Структура макета: Табличный документ с XML:
//     * Элементы (список): Items,
//       * Вложенный элемент списка: Item, с атрибутами соответствующими колонкам результата.
//
// Параметры:
//  ИмяМакета - Строка - имя общего макета из которого берутся представления
// Возвращаемое значение:
//  ТаблицаЗначений - см. ПустаяТаблицаПредставленийПолей()
//
Функция ПредставленияПолей(ИмяМакета)
	
	ТаблицаПредставлений = ПустаяТаблицаПредставленийПолей();
	
	Если ИмяМакета = Неопределено Тогда
		Возврат ТаблицаПредставлений;
	КонецЕсли;
	
	Макет = УправлениеПечатью.МакетПечатнойФормы(ИмяМакета);
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Макет.ПолучитьТекст());
	
	Если Не ЧтениеXML.Прочитать() Тогда //пустой макет вполне валиден
		Возврат ТаблицаПредставлений;
	ИначеЕсли ЧтениеXML.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли ЧтениеXML.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		СтрокаПредставления = ТаблицаПредставлений.Добавить();
		СтрокаПредставления.ПространствоИмен = ЧтениеXML.ПолучитьАтрибут("ПространствоИмен");
		СтрокаПредставления.ЛокальноеИмя     = ЧтениеXML.ПолучитьАтрибут("ЛокальноеИмя");
		СтрокаПредставления.Представление    = ЧтениеXML.ПолучитьАтрибут("Представление");
		СтрокаПредставления.Глубина          = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЧтениеXML.ПолучитьАтрибут("Глубина"));
		СтрокаПредставления.Обязательное     = Булево(СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЧтениеXML.ПолучитьАтрибут("Обязательное")));
		
	КонецЦикла;
	
	ТаблицаПредставлений.Сортировать("ПространствоИмен Возр");
	
	Возврат ТаблицаПредставлений;
	
КонецФункции

#КонецОбласти

Процедура ПеренестиДеревоРекурсивно(ДеревоИсточник, ДеревоПриемник, ОчищатьПриемник = Истина) Экспорт
	
	Если ОчищатьПриемник Тогда 
		ДеревоПриемник.ПолучитьЭлементы().Очистить();
	КонецЕсли;
	
	Для Каждого Элемент Из ДеревоИсточник.ПолучитьЭлементы() Цикл
		
		НовыйЭлемент = ДеревоПриемник.ПолучитьЭлементы().Добавить();
		ЗаполнитьЗначенияСвойств(НовыйЭлемент, Элемент);
		ПеренестиДеревоРекурсивно(Элемент,НовыйЭлемент,Ложь);
		
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает видимость команды "Выполнить обмен" в формах документов, протокола и панели обмена.
//
Процедура УстановитьВидимостьКомандыВыполнитьОбмен(Форма, ТипыДляОбмена, ИменаЭлементов) Экспорт
	
	Если ТипыДляОбмена=Неопределено Или НЕ ПравоИзмененияДокументовИзОпределяемогоТипа(ТипыДляОбмена) Тогда
		Для Каждого ЭлементФормы Из СтрРазделить(ИменаЭлементов, ",", Ложь) Цикл
			Кнопка = Форма.Элементы.Найти(ЭлементФормы);
			Если Кнопка <> Неопределено Тогда
				Кнопка.Видимость = Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура СоставитьСтрокуСоставаУпаковки(СтрокаСостава, СтрокиТекущейЧасти, Знач ОграничительСостава, Уровень = 1)
	
	ЭтоПоследнийУровень = Не Уровень = 1;
	ОграничительСостава = Цел(ОграничительСостава / СтрокиТекущейЧасти.Количество());
	
	Для Каждого СтрокаЧастиНаименования Из СтрокиТекущейЧасти Цикл
		
		Если Не ПустаяСтрока(СтрокаСостава) Тогда
			Если Уровень = 1 Тогда
				Если Прав(СтрокаСостава, 1) = "," Тогда
					СтрокаСостава = Сред(СтрокаСостава, 1, СтрДлина(СтрокаСостава) - 1);
				КонецЕсли;
				СтрокаСостава = СтрокаСостава + ";";
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрокаЧастиНаименования["ЧастьНаименования" + Уровень]) Тогда
			СтрокаСостава = СтрШаблон("%1 %2", СтрокаСостава, СтрокаЧастиНаименования["ЧастьНаименования" + Уровень]);
		КонецЕсли;
		
		СтрокиСледующейЧасти = СтрокаЧастиНаименования.Строки;
		
		Если СтрокиСледующейЧасти.Количество() > 0
			И Цел(ОграничительСостава / СтрокиСледующейЧасти.Количество()) > 0 Тогда
			СоставитьСтрокуСоставаУпаковки(СтрокаСостава, СтрокиСледующейЧасти, ОграничительСостава, Уровень + 1);
			ЭтоПоследнийУровень = Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ЭтоПоследнийУровень Тогда
		СтрокаСостава = СтрокаСостава + ",";
	КонецЕсли;
	
КонецПроцедуры

// Проверяет, что проверяемый индекс операции является более общим для исходного индекса операции последовательности.
//
// Параметры:
//  ИндексОперации - Число - Индекс операции.
//  ИсходныйИндекс - Число - Исходный индекс операции.
// 
// Возвращаемое значение:
//  Булево - Исходный индекс операции принадлежит к индексу текущий операции.
//
Функция ПроверитьИндекс(ИндексОперации, ИсходныйИндекс)
	
	Если ИндексОперации <> ИсходныйИндекс Тогда
		Если СтрДлина(ИсходныйИндекс) = СтрДлина(ИндексОперации) Тогда
			Возврат Истина;
		Иначе
			Если СтрДлина(ИсходныйИндекс) > 1 Тогда
				Возврат ПроверитьИндекс(ИндексОперации, Лев(ИсходныйИндекс, СтрДлина(ИсходныйИндекс) - 1));
			Иначе
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция БазовыеПараметрыОбработкиТабличнойЧастиТовары(ВидыПродукции = Неопределено)
	
	ПараметрыЗаполнения = Новый Структура;
	
	ПараметрыЗаполнения.Вставить("ВидыПродукцииИС",                Новый Массив);
	ПараметрыЗаполнения.Вставить("ЗаполнитьАртикул",               Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьКод",                   Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьЕдиницуИзмерения",      Истина);
	ПараметрыЗаполнения.Вставить("ЗаполнитьТипНоменклатуры",       Истина);
	ПараметрыЗаполнения.Вставить("ОбработатьУпаковки",             Истина);
	ПараметрыЗаполнения.Вставить("ПересчитатьКоличествоЕдиниц",    Истина);
	ПараметрыЗаполнения.Вставить("ПересчитатьКоличествоУпаковок",  Истина);
	ПараметрыЗаполнения.Вставить("ПересчитатьСумму",               Ложь);
	ПараметрыЗаполнения.Вставить("ПересчитатьЦенуПоСумме",         Ложь);
	ПараметрыЗаполнения.Вставить("ПроверитьСериюРассчитатьСтатус", Ложь);
	ПараметрыЗаполнения.Вставить("ШтрихкодыВТЧ",                   Ложь);
	ПараметрыЗаполнения.Вставить("МаркируемаяПродукцияВТЧ",        Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьКодТНВЭД",              Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьСтавкуНДС",             Ложь);
	
	Если ВидыПродукции <> Неопределено Тогда
		ПараметрыЗаполнения.ВидыПродукцииИС = ВидыПродукции;
	КонецЕсли;
	
	Возврат ПараметрыЗаполнения;
	
КонецФункции

// Возвращает признак возможности использования обработки ПанельАдминистрированияБСП.
// 
// Возвращаемое значение:
//  Булево - признак возможности использования текущим пользователем обработки ПанельАдминистрированияБСП.
//
Функция ПравоДоступаПанельАдминистрированиеБСП() Экспорт
	
	Возврат Ложь;
	
КонецФункции

// см. ОбщегоНазначенияПереопределяемый.ПриДобавленииПараметровРаботыКлиента
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	ДобавитьПараметрВыборТипПодписиБСП = Ложь;
	
	Если ПодсистемаСуществует("ИСМП") Тогда
		ДобавитьПараметрВыборТипПодписиБСП = Истина;
		МодульОбщегоНазначенияИСМП = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияИСМП");
		МодульОбщегоНазначенияИСМП.ПриДобавленииПараметровРаботыКлиента(Параметры);
	КонецЕсли;
	
	Если ПодсистемаСуществует("ЗЕРНО") Тогда
		
		ДобавитьПараметрВыборТипПодписиБСП = Истина;
		
		МодульИнтеграцияЗЕРНО = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЗЕРНО");
		МодульИнтеграцияЗЕРНО.ПриДобавленииПараметровРаботыКлиента(Параметры);
		
	КонецЕсли;
	
	Если ДобавитьПараметрВыборТипПодписиБСП Тогда
		
		ВерсияБСП = СтандартныеПодсистемыСервер.ВерсияБиблиотеки();
		
		ИменаПараметров = ИнтеграцияИСКлиентСерверПовтИсп.ИменаПараметровРаботыКлиентаВыборТипаПодписиБСП();
		Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБСП, "3.1.7.247") >= 0 Тогда
			Параметры.Вставить(ИменаПараметров.ИмяПараметраПриложения, ИменаПараметров.ЗначениеПараметраВыборТипаПодписиИспользуетКонструктор);
		ИначеЕсли ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБСП, "3.1.7.61") >= 0 Тогда
			Параметры.Вставить(ИменаПараметров.ИмяПараметраПриложения, ИменаПараметров.ЗначениеПараметраВыборТипаПодписиЗадаетсяПеречислением);
		Иначе
			Параметры.Вставить(ИменаПараметров.ИмяПараметраПриложения, ИменаПараметров.ЗначениеПараметраВыборТипаПодписиНеПоддерживается);
		КонецЕсли;
	
	КонецЕсли;
	
КонецПроцедуры

Процедура НастроитьПодключаемоеОборудование(Форма, ПоддерживаемыеТипыПодключаемогоОборудования, ПрефиксыЭлементовФормы = "Товары") Экспорт
	
	ИнтеграцияИСПереопределяемый.НастроитьПодключаемоеОборудование(Форма, ПрефиксыЭлементовФормы);
	
	ВерсияБПО = МенеджерОборудования.ВерсияБиблиотеки();
	
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБПО, "3.2.1.0") >= 0 Тогда
		
		МодульМенеджерОборудованияКлиентСервер = ОбщегоНазначения.ОбщийМодуль("МенеджерОборудованияКлиентСервер");
		МодульМенеджерОборудования             = ОбщегоНазначения.ОбщийМодуль("МенеджерОборудования");
		
		ТипыОборудования = МодульМенеджерОборудованияКлиентСервер.ПараметрыТипыОборудования();
		ТипыОборудования.СканерШтрихкода = (СтрНайти(ПоддерживаемыеТипыПодключаемогоОборудования, "СканерШтрихкода") > 0);
		ТипыОборудования.СчитывательRFID = (СтрНайти(ПоддерживаемыеТипыПодключаемогоОборудования, "СчитывательRFID") > 0);
		
		МодульМенеджерОборудования.ПриСозданииНаСервере(Форма, ТипыОборудования);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти



